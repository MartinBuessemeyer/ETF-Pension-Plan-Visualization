{"version":3,"sources":["helpers/utils.js","model/ForecastModel.js","model/InvestmentModel.js","renderer/LineChartd3.js","components/InputForm.js","App.js","reportWebVitals.js","index.js"],"names":["timeDiffIgnoreDivisor","numberOfMonthsOfAYear","isFirstMonthOfAYear","date","getMonth","loadHistoricalETFData","etfIdentifier","apiKey","a","d3","entry","Date","timestamp","toString","dividend","parseFloat","course","historicalData","sort","b","etfHistoricalToCourseForecastArray","map","dateToTimestamp","etfHistoricalToDividendForecastArray","currentYear","getFullYear","dividendForecastArray","forEach","length","push","Math","floor","getTime","ForecastModelSingleton","this","coursePredictors","dividendPredictors","courseForecastArray","maxTimestampBeforeCoursePredictorRepetition","_calculateMaxTimestampBeforePredictorRepetition","maxYearBeforeDividendPredictorRepetition","history","forecastArray","lastTimestampToIncludeInPrediction","abs","backCastTimeFactor","backCastTimestampConstant","filteredForecastArray","filter","regression","linear","order","precision","year","lastYearToIncludeInPrediction","_courseDateToPredictorTimestampAndDateTimestamp","predictorTimestamp","_createCoursePredictorIfNotPresent","predict","predictorYear","_dividendYearToPredictorYear","_createDividendPredictorIfNotPresent","max","backCastTimeConstant","backCastTimeDate","setMonth","instance","getInstance","firstTimestamp","lastTimestamp","corporateTaxRatio","getNextMonthDate","newDate","calculateDividend","isLastMonthOfAYear","predictDividend","calculateCosts","amount","costConfiguration","costs","percentageCosts","fixedCosts","amountWithoutCosts","subtractTaxFreeGain","taxAmount","taxFreeAmount","getTotalShareValue","investmentStep","totalShares","sharePrizes","getNewShareValue","newShares","addAccumulationMonth","investmentSteps","investment","etfToRatio","configOptions","forecast","prevInvestmentStep","newInvestmentStep","dividendNewShares","dividendTotalShares","totalCosts","totalInvestedMoney","totalTaxes","totalPayout","newPayout","costConfig","investmentOfEtfWithoutCosts","etfSharePrize","predictCourse","dividendPayoutMoneyPerShare","newSharesByDividend","leftoverTaxFreeAmount","value","min","summedTaxes","decemberInvestmentStep","firstInvestmentStepOfThisYear","accumulatedBasicProfit","i","profitOverAllTime","profitOfPreviousYears","amountToApplyTaxes","calculateTaxes","newTaxes","newLeftoverTaxFreeAmount","addPayoutMonth","sellingAmount","leftoverAlreadyPaidTaxes","payoutStats","taxes","investmentStepsIdx","amountToSell","amountAlreadySold","costsToPay","alreadyPaidCosts","payoutInvestmentStepIdxForFIFO","currentSharesLeft","alreadySoldShares","leftoverAmountToSell","currentInvestmentStepForFIFO","currentValueOfShares","amountToSellWithCosts","amountOfSharesToSell","amountToSellWithoutCosts","initialValueOfShares","amountToPayTaxes","taxesToPay","payoutAmount","amountOfDividendSharesLeft","amountOfDividendSharesSold","generateEmptyInvestmentStep","emptyInvestmentStep","InvestmentModel","startCapital","monthlyInvestment","monthlyPayout","savingPhaseLength","age","expectationOfLife","_calculateTimestampsForModel","_calculateModel","lifeExpectation","fadeOutYears","yearsLeft","now","beginningDate","endSavingPhaseDate","setFullYear","endDate","calculateForecastInterval","startDate","savingDates","currentDate","payoutDates","slice","savingDate","payoutDate","LineChart3D","renderDivRef","innerHTML","svg","append","attr","width","height","dataToIndex","inflation","currentIdx","capitalIdentifier","dividendIdentifier","lineData","heightOffset","totalShareValue","totalDividendShareValue","cssClass","minVal","e","maxVal","yScale","domain","range","dateExtent","d","xScale","style","call","tickFormat","toLocaleString","datum","x","y","STARTING_CAPITAL_IDENTIFIER","MONTHLY_INVESTMENT_IDENTIFIER","TRANSACTION_COSTS_IDENTIFIER","TRANSACTION_COSTS_TYPE_IDENTIFIER","SAVING_PHASE_IDENTIFIER","AGE_IDENTIFIER","TAX_FREE_AMOUNT_IDENTIFIER","MONTHLY_PAYOUT_IDENTIFIER","LIFE_EXPECTATION","identifierToLabel","transformInputToInt","caller","intVal","parseInt","target","isNaN","transformInputToFloat","transformCheckboxInput","props","InputForm","state","type","transformFunction","ref","React","createRef","handleChange","bind","changedValue","changedStateIdentifier","setState","console","log","IBM","configure","forecastModel","loadAndCacheHistoricalETFData","render","getVisualizationModel","current","Fragment","Object","keys","stateIdentifier","label","onValueChange","Component","InputFormElement","onChange","App","className","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.52fcc405.chunk.js","sourcesContent":["import * as d3 from 'd3';\n\n// Ignore milliseconds, seconds, minutes.\nconst timeDiffIgnoreDivisor = 1000 * 60 * 60 * 24;\n\nexport const timestampIndexOfForecastArray = 0;\nexport const courseIndexOfForecastArray = 1;\nexport const numberOfMonthsOfAYear = 12;\nexport const inflationRate = 0.01;\n\nexport function isLastMonthOfAYear(date) {\n    return date.getMonth() === numberOfMonthsOfAYear - 1;\n}\n\nexport function clamp(value, min, max) {\n    return Math.max(min, Math.min(value, max));\n}\n\nexport function isFirstMonthOfAYear(date) {\n    return date.getMonth() === 0;\n}\n\nexport function intervalIsEndOfYear(startDate, endDate) {\n    return startDate.getFullYear() < endDate.getFullYear();\n}\n\nexport function roundToMoneyAmount(amount) {\n    return Math.round(amount * 100.0) / 100.0;\n}\n\nexport async function loadHistoricalETFData(etfIdentifier, apiKey) {\n    const historicalData = await d3.csv(\n        `https://www.alphavantage.co/query?function=TIME_SERIES_MONTHLY_ADJUSTED&symbol=${etfIdentifier}&apikey=${apiKey}&datatype=csv`,\n        entry => {\n            return {\n                date: new Date(entry.timestamp.toString()),\n                dividend: parseFloat(entry['dividend amount']),\n                course: parseFloat(entry['adjusted close']),\n            };\n        }\n    );\n    historicalData.sort((a, b) => a.date - b.date);\n    return historicalData;\n}\n\nexport function etfHistoricalToCourseForecastArray(historicalData) {\n    return historicalData.map(entry => [dateToTimestamp(entry.date), entry.course]);\n}\n\n// Requires sorted historical data. Note it is sorted by default. Do not change the order.\nexport function etfHistoricalToDividendForecastArray(historicalData) {\n    let currentYear = historicalData[0].date.getFullYear();\n    const dividendForecastArray = [[currentYear, 0]];\n    historicalData.forEach(entry => {\n        if (entry.date.getFullYear() === currentYear) {\n            dividendForecastArray[dividendForecastArray.length - 1][courseIndexOfForecastArray] += entry.dividend;\n        } else {\n            currentYear = entry.date.getFullYear();\n            dividendForecastArray.push([currentYear, entry.dividend]);\n        }\n    });\n    dividendForecastArray.sort((a, b) => a[timestampIndexOfForecastArray] - b[timestampIndexOfForecastArray]);\n    return dividendForecastArray;\n}\n\nexport function dateToTimestamp(date) {\n    return Math.floor(date.getTime() / timeDiffIgnoreDivisor);\n}\n\nexport function timestampToDate(timestamp) {\n    return new Date(timestamp * timeDiffIgnoreDivisor);\n}\n\nexport default numberOfMonthsOfAYear;\n","import regression from 'regression';\nimport {\n    dateToTimestamp,\n    etfHistoricalToCourseForecastArray,\n    etfHistoricalToDividendForecastArray,\n    loadHistoricalETFData,\n    timestampToDate,\n    timestampIndexOfForecastArray,\n    courseIndexOfForecastArray,\n} from '../helpers/utils';\n\n// USAGE: first call configure to set required static vars. Then the singleton can be accessed via getInstance. Never call the Constructor on your own.\n// Always call loadAndCacheHistoricalETFData of an etf before calling predict on that etf.\nexport class ForecastModelSingleton {\n    static instance = null;\n    static apiKey = null;\n    static backCastTimeConstant = null;\n    static backCastTimeFactor = null;\n\n    // DO NOT CALL. USE getInstance()\n    constructor() {\n        this.historicalData = {};\n        this.coursePredictors = {};\n        this.dividendPredictors = {};\n    }\n\n    static configure(apiKey, backCastTimeFactor = 2, backCastTimeConstant = 7) {\n        ForecastModelSingleton.apiKey = apiKey;\n        ForecastModelSingleton.backCastTimeFactor = backCastTimeFactor;\n\n        const backCastTimeDate = new Date(0);\n        backCastTimeDate.setMonth(backCastTimeConstant);\n        ForecastModelSingleton.backCastTimestampConstant = dateToTimestamp(backCastTimeDate);\n\n        // reset predictors if present.\n        if (ForecastModelSingleton.instance != null) {\n            const instance = ForecastModelSingleton.getInstance();\n            for (const etfIdentifier in instance.coursePredictors) {\n                instance.coursePredictors[etfIdentifier] = {\n                    maxTimestampBeforeCoursePredictorRepetition: ForecastModelSingleton._calculateMaxTimestampBeforePredictorRepetition(\n                        instance.historicalData[etfIdentifier].courseForecastArray\n                    ),\n                };\n            }\n            for (const etfIdentifier in instance.dividendPredictors) {\n                instance.dividendPredictors[etfIdentifier] = {\n                    maxYearBeforeDividendPredictorRepetition: ForecastModelSingleton._calculateMaxTimestampBeforePredictorRepetition(\n                        instance.historicalData[etfIdentifier].dividendForecastArray\n                    ),\n                };\n            }\n        }\n    }\n\n    static getInstance() {\n        if (ForecastModelSingleton.instance == null) {\n            ForecastModelSingleton.instance = new ForecastModelSingleton();\n        }\n        return ForecastModelSingleton.instance;\n    }\n\n    static _calculateMaxTimestampBeforePredictorRepetition(forecastArray) {\n        const firstTimestamp = forecastArray[0][timestampIndexOfForecastArray];\n        const lastTimestamp = forecastArray[forecastArray.length - 1][timestampIndexOfForecastArray];\n        return lastTimestamp + (lastTimestamp - firstTimestamp) / ForecastModelSingleton.backCastTimeFactor;\n    }\n\n    async loadAndCacheHistoricalETFData(etfIdentifier) {\n        if (etfIdentifier in this.historicalData) {\n            return;\n        }\n        const historicalData = await loadHistoricalETFData(etfIdentifier);\n\n        const courseForecastArray = etfHistoricalToCourseForecastArray(historicalData);\n        const maxTimestampBeforeCoursePredictorRepetition = ForecastModelSingleton._calculateMaxTimestampBeforePredictorRepetition(\n            courseForecastArray\n        );\n\n        const dividendForecastArray = etfHistoricalToDividendForecastArray(historicalData);\n        const maxYearBeforeDividendPredictorRepetition = ForecastModelSingleton._calculateMaxTimestampBeforePredictorRepetition(\n            dividendForecastArray\n        );\n\n        this.historicalData[etfIdentifier] = {\n            history: historicalData,\n            courseForecastArray: courseForecastArray,\n            dividendForecastArray: dividendForecastArray,\n        };\n        this.coursePredictors[etfIdentifier] = {\n            maxTimestampBeforeCoursePredictorRepetition: maxTimestampBeforeCoursePredictorRepetition,\n        };\n        this.dividendPredictors[etfIdentifier] = {\n            maxYearBeforeDividendPredictorRepetition: maxYearBeforeDividendPredictorRepetition,\n        };\n    }\n\n    _createCoursePredictorIfNotPresent(etfIdentifier, timestamp) {\n        // Skip if already exists.\n        if (timestamp in this.coursePredictors[etfIdentifier]) {\n            return;\n        }\n        const forecastArray = this.historicalData[etfIdentifier].courseForecastArray;\n        const lastTimestampToIncludeInPrediction =\n            forecastArray[forecastArray.length - 1][timestampIndexOfForecastArray] -\n            Math.abs(forecastArray[forecastArray.length - 1][timestampIndexOfForecastArray] - timestamp) *\n                ForecastModelSingleton.backCastTimeFactor -\n            ForecastModelSingleton.backCastTimestampConstant;\n        const filteredForecastArray = forecastArray.filter(\n            entry => entry[timestampIndexOfForecastArray] >= lastTimestampToIncludeInPrediction\n        );\n        this.coursePredictors[etfIdentifier][timestamp] = regression.linear(filteredForecastArray, {\n            order: 2,\n            precision: 20,\n        });\n    }\n\n    _courseDateToPredictorTimestampAndDateTimestamp(date, etfIdentifier) {\n        const timestamp = dateToTimestamp(date);\n        return [\n            timestamp > this.coursePredictors[etfIdentifier].maxTimestampBeforeCoursePredictorRepetition\n                ? this.coursePredictors[etfIdentifier].maxTimestampBeforeCoursePredictorRepetition\n                : timestamp,\n            timestamp,\n        ];\n    }\n\n    _createDividendPredictorIfNotPresent(etfIdentifier, year) {\n        // Skip if already exists.\n        if (year in this.dividendPredictors[etfIdentifier]) {\n            return;\n        }\n        const forecastArray = this.historicalData[etfIdentifier].dividendForecastArray;\n        const lastYearToIncludeInPrediction =\n            forecastArray[forecastArray.length - 1][timestampIndexOfForecastArray] -\n            Math.abs(forecastArray[forecastArray.length - 1][timestampIndexOfForecastArray] - year) *\n                ForecastModelSingleton.backCastTimeFactor -\n            ForecastModelSingleton.backCastTimestampConstant;\n        const filteredForecastArray = forecastArray.filter(\n            entry => entry[timestampIndexOfForecastArray] >= lastYearToIncludeInPrediction\n        );\n        this.dividendPredictors[etfIdentifier][year] = regression.linear(filteredForecastArray, {\n            order: 2,\n            precision: 20,\n        });\n    }\n\n    _dividendYearToPredictorYear(etfIdentifier, year) {\n        return this.dividendPredictors[etfIdentifier].maxYearBeforeDividendPredictorRepetition < year\n            ? this.dividendPredictors[etfIdentifier].maxYearBeforeDividendPredictorRepetition\n            : year;\n    }\n\n    predictCourse(etfIdentifier, date) {\n        if (!(etfIdentifier in this.coursePredictors)) {\n            throw `First call loadHistoricalDataIfNotPresent() before predicting: ${etfIdentifier}`;\n        }\n        const [predictorTimestamp, timestamp] = this._courseDateToPredictorTimestampAndDateTimestamp(\n            date,\n            etfIdentifier\n        );\n        this._createCoursePredictorIfNotPresent(etfIdentifier, predictorTimestamp);\n        return this.coursePredictors[etfIdentifier][predictorTimestamp].predict(timestamp)[courseIndexOfForecastArray];\n    }\n\n    predictDividend(etfIdentifier, year) {\n        if (!(etfIdentifier in this.dividendPredictors)) {\n            throw `First call loadHistoricalDataIfNotPresent() before predicting: ${etfIdentifier}`;\n        }\n        const predictorYear = this._dividendYearToPredictorYear(etfIdentifier, year);\n        this._createDividendPredictorIfNotPresent(etfIdentifier, predictorYear);\n        return Math.max(\n            0,\n            this.dividendPredictors[etfIdentifier][predictorYear].predict(year)[courseIndexOfForecastArray]\n        );\n    }\n}\n\nexport default ForecastModelSingleton;\n","import ForecastModelSingleton from './ForecastModel';\nimport { numberOfMonthsOfAYear, isLastMonthOfAYear, clamp, isFirstMonthOfAYear } from '../helpers/utils';\n\nconst basicRateOfInterest = 0.007;\nconst partialExemption = 0.7;\nconst corporateTaxRatio = 0.26375;\n\nfunction getNextMonthDate(date) {\n    const newDate = new Date(date);\n    newDate.setMonth(date.getMonth() + 1);\n    return newDate;\n}\n\nfunction calculateDividend(etfIdentifier, date) {\n    if (!isLastMonthOfAYear(date)) {\n        return 0;\n    } else {\n        return ForecastModelSingleton.getInstance().predictDividend(etfIdentifier, date.getFullYear());\n    }\n}\n\nfunction calculateCosts(amount, costConfiguration) {\n    let costs = amount * costConfiguration.percentageCosts + costConfiguration.fixedCosts;\n    const amountWithoutCosts = Math.max(amount - costs, 0);\n    costs = amount - amountWithoutCosts;\n    return [amountWithoutCosts, costs];\n}\n\nfunction subtractTaxFreeGain(taxAmount, taxFreeAmount) {\n    const leftoverTaxes = Math.max(0, taxAmount - taxFreeAmount);\n    const leftoverTaxFreeAmount = Math.max(0, taxFreeAmount - taxAmount);\n    return [leftoverTaxes, leftoverTaxFreeAmount];\n}\n\nexport function getTotalShareValue(etfIdentifier, investmentStep) {\n    return investmentStep.totalShares[etfIdentifier] * investmentStep.sharePrizes[etfIdentifier];\n}\n\nfunction getNewShareValue(etfIdentifier, investmentStep) {\n    return investmentStep.newShares[etfIdentifier] * investmentStep.sharePrizes[etfIdentifier];\n}\n\nfunction calculateForecastInterval(age, lifeExpectation, savingPhaseLength, fadeOutYears = 10) {\n    const yearsLeft = lifeExpectation - age;\n    const now = new Date();\n    const beginningDate = new Date(now.getFullYear(), now.getMonth() + 1);\n    // start next month.\n    const endSavingPhaseDate = new Date(beginningDate);\n    endSavingPhaseDate.setFullYear(beginningDate.getFullYear() + savingPhaseLength);\n    const endDate = new Date(beginningDate);\n    endDate.setFullYear(beginningDate.getFullYear() + yearsLeft + fadeOutYears);\n    return [beginningDate, endSavingPhaseDate, endDate];\n}\n\nfunction calculateTaxes(investmentSteps, date, leftoverTaxFreeAmount, etfToRatio) {\n    if (!isFirstMonthOfAYear(date) || investmentSteps.length < 2) {\n        return [0, leftoverTaxFreeAmount];\n    }\n    let summedTaxes = 0;\n    const decemberInvestmentStep = investmentSteps[investmentSteps.length - 1];\n    // Use the second investment step if there are not enough meaning the investing started this year after january.\n    // The second is the true first investment step the first is a dummy.\n    const firstInvestmentStepOfThisYear =\n        investmentSteps.length - numberOfMonthsOfAYear > 1\n            ? investmentSteps[investmentSteps.length - numberOfMonthsOfAYear]\n            : investmentSteps[1];\n    for (const etfIdentifier in etfToRatio) {\n        let accumulatedBasicProfit = 0;\n        // Sum up all new investments from february to december.\n        for (let i = 1; i < numberOfMonthsOfAYear && investmentSteps.length - i > 0; i++) {\n            const currentInvestmentStep = investmentSteps[investmentSteps.length - i];\n            accumulatedBasicProfit +=\n                (getNewShareValue(etfIdentifier, currentInvestmentStep) * i) / numberOfMonthsOfAYear;\n        }\n        // Sum up total Investment of the first date of this year.\n        accumulatedBasicProfit +=\n            (getTotalShareValue(etfIdentifier, firstInvestmentStepOfThisYear) *\n                (numberOfMonthsOfAYear - firstInvestmentStepOfThisYear.date.getMonth())) /\n            numberOfMonthsOfAYear;\n        accumulatedBasicProfit *= 0.7 * basicRateOfInterest;\n        const currentShareValues = getTotalShareValue(etfIdentifier, decemberInvestmentStep);\n        // Calculate profit of last year.\n        const profitOverAllTime = currentShareValues - decemberInvestmentStep.totalInvestedMoney[etfIdentifier];\n        let profitOfPreviousYears = 0;\n        if (investmentSteps.length > numberOfMonthsOfAYear) {\n            profitOfPreviousYears = Math.max(\n                0,\n                getTotalShareValue(etfIdentifier, investmentSteps[investmentSteps.length - 1 - numberOfMonthsOfAYear]) -\n                    investmentSteps[investmentSteps.length - 1 - numberOfMonthsOfAYear].totalInvestedMoney[\n                        etfIdentifier\n                    ]\n            );\n        }\n\n        const profitOfThisYear = profitOverAllTime - profitOfPreviousYears;\n        let amountToApplyTaxes = clamp(profitOfThisYear, 0, accumulatedBasicProfit);\n        [amountToApplyTaxes, leftoverTaxFreeAmount] = subtractTaxFreeGain(amountToApplyTaxes, leftoverTaxFreeAmount);\n        summedTaxes += amountToApplyTaxes * partialExemption * corporateTaxRatio;\n    }\n    return [summedTaxes, leftoverTaxFreeAmount];\n}\n\nexport function addAccumulationMonth(investmentSteps, investment, date, etfToRatio, configOptions) {\n    const forecast = ForecastModelSingleton.getInstance();\n    let costs = 0;\n    const prevInvestmentStep = investmentSteps[investmentSteps.length - 1];\n    const newInvestmentStep = {\n        date: date,\n        newShares: {},\n        totalShares: { ...prevInvestmentStep.totalShares },\n        dividendNewShares: {},\n        dividendTotalShares: { ...prevInvestmentStep.dividendTotalShares },\n        totalCosts: prevInvestmentStep.totalCosts,\n        sharePrizes: {},\n        totalInvestedMoney: { ...prevInvestmentStep.totalInvestedMoney },\n        totalTaxes: prevInvestmentStep.totalTaxes,\n        totalPayout: { ...prevInvestmentStep.totalPayout },\n        newPayout: {},\n    };\n    for (const etfIdentifier in etfToRatio) {\n        const investmentOfEtfWithCosts = etfToRatio[etfIdentifier] * investment;\n        const [investmentOfEtfWithoutCosts, newCosts] = calculateCosts(\n            investmentOfEtfWithCosts,\n            configOptions.costConfig\n        );\n        costs += newCosts;\n        newInvestmentStep.totalInvestedMoney[etfIdentifier] += investmentOfEtfWithoutCosts;\n\n        const etfSharePrize = forecast.predictCourse(etfIdentifier, date);\n        const newShares = investmentOfEtfWithoutCosts / etfSharePrize;\n        newInvestmentStep.sharePrizes[etfIdentifier] = etfSharePrize;\n        newInvestmentStep.newShares[etfIdentifier] = newShares;\n\n        const dividendPayoutMoneyPerShare = calculateDividend(etfIdentifier, date);\n        const dividendPayoutMoney = newInvestmentStep.totalShares[etfIdentifier] * dividendPayoutMoneyPerShare;\n        const newSharesByDividend = dividendPayoutMoney / etfSharePrize;\n        newInvestmentStep.newShares[etfIdentifier] += newSharesByDividend;\n        newInvestmentStep.dividendNewShares[etfIdentifier] = newSharesByDividend;\n        newInvestmentStep.dividendTotalShares[etfIdentifier] += newSharesByDividend;\n\n        newInvestmentStep.totalShares[etfIdentifier] += newInvestmentStep.newShares[etfIdentifier];\n        newInvestmentStep.newPayout[etfIdentifier] = 0;\n    }\n    newInvestmentStep.totalCosts += costs;\n    const [newTaxes, newLeftoverTaxFreeAmount] = calculateTaxes(\n        investmentSteps,\n        date,\n        configOptions.taxFreeAmount,\n        etfToRatio\n    );\n    newInvestmentStep.totalTaxes += newTaxes;\n    investmentSteps.push(newInvestmentStep);\n\n    return newLeftoverTaxFreeAmount;\n}\n\nfunction addPayoutMonth(\n    investmentSteps,\n    sellingAmount,\n    etfToRatio,\n    date,\n    configOptions,\n    leftoverAlreadyPaidTaxes,\n    leftoverTaxFreeAmount,\n    payoutStats\n) {\n    if (isFirstMonthOfAYear(date)) {\n        leftoverTaxFreeAmount = configOptions.taxFreeAmount;\n    }\n    const forecast = ForecastModelSingleton.getInstance();\n    let costs = 0;\n    let taxes = 0;\n    const prevInvestmentStep = investmentSteps[investmentSteps.length - 1];\n    const newInvestmentStep = {\n        date: date,\n        newShares: {},\n        totalShares: { ...prevInvestmentStep.totalShares },\n        dividendNewShares: {},\n        dividendTotalShares: { ...prevInvestmentStep.dividendTotalShares },\n        totalCosts: prevInvestmentStep.totalCosts,\n        sharePrizes: {},\n        totalInvestedMoney: { ...prevInvestmentStep.totalInvestedMoney },\n        totalTaxes: prevInvestmentStep.totalTaxes,\n        totalPayout: { ...prevInvestmentStep.totalPayout },\n        newPayout: {},\n    };\n    for (const etfIdentifier in etfToRatio) {\n        const etfSharePrize = forecast.predictCourse(etfIdentifier, date);\n        newInvestmentStep.sharePrizes[etfIdentifier] = etfSharePrize;\n        newInvestmentStep.newPayout[etfIdentifier] = 0;\n        // Skip payout if there are no shares left to sell.\n        if (payoutStats[etfIdentifier].investmentStepsIdx < investmentSteps.length) {\n            // Handle payout.\n            const amountToSell = sellingAmount * etfToRatio[etfIdentifier];\n            let amountAlreadySold = 0;\n            const costsToPay = calculateCosts(amountToSell, configOptions.costConfig)[1];\n            let alreadyPaidCosts = 0;\n            let payoutInvestmentStepIdxForFIFO = payoutStats[etfIdentifier].investmentStepsIdx;\n            let currentSharesLeft =\n                investmentSteps[payoutInvestmentStepIdxForFIFO].newShares[etfIdentifier] -\n                payoutStats[etfIdentifier].alreadySoldShares;\n            for (; payoutInvestmentStepIdxForFIFO < investmentSteps.length; payoutInvestmentStepIdxForFIFO++) {\n                const leftoverAmountToSell = amountToSell - amountAlreadySold;\n                const currentInvestmentStepForFIFO = investmentSteps[payoutInvestmentStepIdxForFIFO];\n\n                const currentValueOfShares =\n                    etfSharePrize *\n                    (payoutInvestmentStepIdxForFIFO === payoutStats[etfIdentifier].investmentStepsIdx\n                        ? currentInvestmentStepForFIFO.newShares[etfIdentifier] -\n                          payoutStats[etfIdentifier].alreadySoldShares\n                        : currentInvestmentStepForFIFO.newShares[etfIdentifier]);\n                const amountToSellWithCosts = Math.min(currentValueOfShares, leftoverAmountToSell);\n                const amountOfSharesToSell = amountToSellWithCosts / etfSharePrize;\n                currentSharesLeft = currentInvestmentStepForFIFO.newShares[etfIdentifier] - amountOfSharesToSell;\n                currentSharesLeft -=\n                    payoutInvestmentStepIdxForFIFO === payoutStats[etfIdentifier].investmentStepsIdx\n                        ? payoutStats[etfIdentifier].alreadySoldShares\n                        : 0;\n\n                const amountToSellWithoutCosts = Math.max(0, amountToSellWithCosts - (costsToPay - alreadyPaidCosts));\n                alreadyPaidCosts += Math.max(0, amountToSellWithCosts - amountToSellWithoutCosts);\n\n                const initialValueOfShares =\n                    amountOfSharesToSell * currentInvestmentStepForFIFO.sharePrizes[etfIdentifier];\n                let amountToPayTaxes = Math.max(0, amountToSellWithoutCosts - initialValueOfShares);\n\n                [amountToPayTaxes, leftoverTaxFreeAmount] = subtractTaxFreeGain(\n                    amountToPayTaxes,\n                    leftoverTaxFreeAmount\n                );\n                let taxesToPay = amountToPayTaxes * partialExemption * corporateTaxRatio;\n                [taxesToPay, leftoverAlreadyPaidTaxes] = subtractTaxFreeGain(taxesToPay, leftoverAlreadyPaidTaxes);\n                taxes += taxesToPay;\n                const payoutAmount = amountToSellWithoutCosts - taxesToPay;\n\n                newInvestmentStep.newPayout[etfIdentifier] += payoutAmount;\n                newInvestmentStep.totalPayout[etfIdentifier] += payoutAmount;\n\n                newInvestmentStep.totalShares[etfIdentifier] -= amountOfSharesToSell;\n                amountAlreadySold += amountToSellWithCosts;\n\n                // Handle the decrease of the dividendShares.\n                let amountOfDividendSharesLeft = 0;\n                if (payoutInvestmentStepIdxForFIFO === payoutStats[etfIdentifier].investmentStepsIdx) {\n                    amountOfDividendSharesLeft = Math.max(\n                        0,\n                        currentInvestmentStepForFIFO.dividendNewShares[etfIdentifier] -\n                            payoutStats[etfIdentifier].alreadySoldShares\n                    );\n                } else {\n                    amountOfDividendSharesLeft = currentInvestmentStepForFIFO.dividendNewShares[etfIdentifier];\n                }\n                const amountOfDividendSharesSold = Math.min(amountOfDividendSharesLeft, amountOfSharesToSell);\n                newInvestmentStep.dividendTotalShares[etfIdentifier] -= amountOfDividendSharesSold;\n\n                // Use break in order to not change the value of payoutInvestmentStepIdxForFIFO.\n                if (amountAlreadySold >= amountToSell) {\n                    break;\n                }\n            }\n            costs += alreadyPaidCosts;\n            // Handle update payoutStats.\n            payoutStats[etfIdentifier].investmentStepsIdx = payoutInvestmentStepIdxForFIFO;\n            payoutStats[etfIdentifier].investmentStepsIdx += currentSharesLeft === 0 ? 1 : 0;\n\n            payoutStats[etfIdentifier].alreadySoldShares =\n                payoutInvestmentStepIdxForFIFO < investmentSteps.length\n                    ? investmentSteps[payoutInvestmentStepIdxForFIFO].newShares[etfIdentifier] - currentSharesLeft\n                    : 0;\n        }\n\n        // Handle dividend.\n        const dividendPayoutMoney =\n            newInvestmentStep.totalShares[etfIdentifier] * calculateDividend(etfIdentifier, date);\n        const newSharesByDividend = dividendPayoutMoney / etfSharePrize;\n        newInvestmentStep.newShares[etfIdentifier] = newSharesByDividend;\n        newInvestmentStep.totalShares[etfIdentifier] += newSharesByDividend;\n        newInvestmentStep.dividendNewShares[etfIdentifier] = newSharesByDividend;\n        newInvestmentStep.dividendTotalShares[etfIdentifier] += newSharesByDividend;\n    }\n\n    newInvestmentStep.totalCosts += costs;\n    newInvestmentStep.totalTaxes += taxes;\n    investmentSteps.push(newInvestmentStep);\n    return [leftoverAlreadyPaidTaxes, leftoverTaxFreeAmount];\n}\n\nfunction generateEmptyInvestmentStep(etfToRatio, date) {\n    const forecast = ForecastModelSingleton.getInstance();\n    const emptyInvestmentStep = {\n        date: date,\n        totalCosts: 0,\n        totalTaxes: 0,\n        newShares: {},\n        totalShares: {},\n        dividendNewShares: {},\n        dividendTotalShares: {},\n        totalInvestedMoney: {},\n        totalPayout: {},\n        newPayout: {},\n        sharePrizes: {},\n    };\n    for (const etfIdentifier in etfToRatio) {\n        emptyInvestmentStep.newShares[etfIdentifier] = 0;\n        emptyInvestmentStep.totalShares[etfIdentifier] = 0;\n        emptyInvestmentStep.dividendNewShares[etfIdentifier] = 0;\n        emptyInvestmentStep.dividendTotalShares[etfIdentifier] = 0;\n        emptyInvestmentStep.totalInvestedMoney[etfIdentifier] = 0;\n        emptyInvestmentStep.totalPayout[etfIdentifier] = 0;\n        emptyInvestmentStep.newPayout[etfIdentifier] = 0;\n        emptyInvestmentStep.sharePrizes[etfIdentifier] = forecast.predictCourse(etfIdentifier, date);\n    }\n    return emptyInvestmentStep;\n}\n\nexport class InvestmentModel {\n    constructor(\n        startCapital,\n        monthlyInvestment,\n        monthlyPayout,\n        savingPhaseLength,\n        etfToRatio,\n        configOptions,\n        age,\n        expectationOfLife\n    ) {\n        this.startCapital = startCapital;\n        this.monthlyInvestment = monthlyInvestment;\n        this.monthlyPayout = monthlyPayout;\n        this.savingPhaseLength = savingPhaseLength;\n        this.etfToRatio = etfToRatio;\n        this.configOptions = configOptions;\n        this.expectationOfLife = expectationOfLife;\n        this.age = age;\n        this._calculateTimestampsForModel();\n        this._calculateModel();\n    }\n\n    _calculateTimestampsForModel() {\n        const [startDate, endSavingPhaseDate, endDate] = calculateForecastInterval(\n            this.age,\n            this.expectationOfLife,\n            this.savingPhaseLength\n        );\n        const savingDates = [];\n        for (\n            let currentDate = startDate;\n            currentDate < endSavingPhaseDate;\n            currentDate = getNextMonthDate(currentDate)\n        ) {\n            savingDates.push(currentDate);\n        }\n        this.savingDates = savingDates;\n        const payoutDates = [];\n        for (let currentDate = endSavingPhaseDate; currentDate < endDate; currentDate = getNextMonthDate(currentDate)) {\n            payoutDates.push(currentDate);\n        }\n        this.payoutDates = payoutDates;\n    }\n\n    _calculateModel() {\n        let investmentSteps = [generateEmptyInvestmentStep(this.etfToRatio, this.savingDates[0])];\n        let leftoverTaxFreeAmount = addAccumulationMonth(\n            investmentSteps,\n            this.monthlyInvestment + this.startCapital,\n            this.savingDates[0],\n            this.etfToRatio,\n            this.configOptions\n        );\n        for (const savingDate of this.savingDates.slice(1)) {\n            leftoverTaxFreeAmount = addAccumulationMonth(\n                investmentSteps,\n                this.monthlyInvestment,\n                savingDate,\n                this.etfToRatio,\n                this.configOptions\n            );\n        }\n        // Discard the empty investment step.\n        investmentSteps = investmentSteps.slice(1);\n\n        let leftoverAlreadyPaidTaxes = investmentSteps[investmentSteps.length - 1].totalTaxes;\n        const payoutStats = {};\n        for (const etfIdentifier in this.etfToRatio) {\n            payoutStats[etfIdentifier] = { investmentStepsIdx: 0, alreadySoldShares: 0 };\n        }\n        for (const payoutDate of this.payoutDates) {\n            [leftoverAlreadyPaidTaxes, leftoverTaxFreeAmount] = addPayoutMonth(\n                investmentSteps,\n                this.monthlyPayout,\n                this.etfToRatio,\n                payoutDate,\n                this.configOptions,\n                leftoverAlreadyPaidTaxes,\n                leftoverTaxFreeAmount,\n                payoutStats\n            );\n        }\n        this.investmentSteps = investmentSteps;\n    }\n}\n","import * as d3 from 'd3';\nimport { getTotalShareValue } from '../model/InvestmentModel';\n\nexport class LineChart3D {\n    render(investmentSteps, renderDivRef) {\n        const svgID = 'firstSVG';\n\n        const marginW = 150,\n            marginH = 40,\n            width = 1000,\n            height = 400;\n\n        const zeroLineStrokeWidth = 3;\n\n        // Reset diagram by deletion.\n        renderDivRef.innerHTML = '';\n\n        const svg = d3\n            .select(renderDivRef)\n            .append('svg')\n            .attr('id', svgID)\n            .attr('height', '100%')\n            .attr('width', '100%')\n            .attr('viewBox', `0 0 ${width + 2 * marginW} ${height + 2 * marginH}`)\n            .append('g')\n            .attr('transform', `translate(${[marginW, marginH]})`);\n\n        // Create line array.\n        const dataToIndex = {\n            costs: 0,\n            taxes: 1,\n            inflation: 2,\n        };\n        let currentIdx = 3;\n        const capitalIdentifier = 'capital';\n        const dividendIdentifier = 'dividend';\n        for (const etfIdentifier in investmentSteps[0].totalShares) {\n            dataToIndex[etfIdentifier + dividendIdentifier] = currentIdx++;\n            dataToIndex[etfIdentifier + capitalIdentifier] = currentIdx++;\n        }\n\n        const lineData = [];\n        for (let i = 0; i < currentIdx; i++) {\n            lineData.push([]);\n        }\n        for (const investmentStep of investmentSteps) {\n            lineData[dataToIndex.costs].push({ value: -investmentStep.totalCosts, date: investmentStep.date });\n            lineData[dataToIndex.taxes].push({\n                value: -investmentStep.totalCosts - investmentStep.totalTaxes,\n                date: investmentStep.date,\n            });\n            lineData[dataToIndex.inflation].push({\n                value: -investmentStep.totalCosts - investmentStep.totalTaxes,\n                date: investmentStep.date,\n            });\n            let heightOffset = 0;\n            for (const etfIdentifier in investmentStep.totalShares) {\n                const totalShareValue = getTotalShareValue(etfIdentifier, investmentStep);\n                const totalDividendShareValue =\n                    investmentStep.dividendTotalShares[etfIdentifier] * investmentStep.sharePrizes[etfIdentifier];\n                lineData[dataToIndex[etfIdentifier + capitalIdentifier]].push({\n                    value: totalShareValue + heightOffset,\n                    date: investmentStep.date,\n                });\n                lineData[dataToIndex[etfIdentifier + dividendIdentifier]].push({\n                    value: totalShareValue - totalDividendShareValue + heightOffset,\n                    date: investmentStep.date,\n                });\n                heightOffset += totalShareValue;\n            }\n        }\n\n        // Append miscellaneous data to array.\n        lineData[dataToIndex.inflation].cssClass = 'inflation';\n        lineData[dataToIndex.taxes].cssClass = 'taxes';\n        lineData[dataToIndex.costs].cssClass = 'costs';\n        for (const etfIdentifier in investmentSteps[0].totalShares) {\n            lineData[dataToIndex[etfIdentifier + dividendIdentifier]].cssClass = `${etfIdentifier}_dividend`;\n            lineData[dataToIndex[etfIdentifier + capitalIdentifier]].cssClass = `${etfIdentifier}_total_amount`;\n        }\n\n        // Create scales.\n        const minVal = d3.min(lineData[dataToIndex.inflation].map(e => e.value));\n        const maxVal = d3.max(lineData[lineData.length - 1].map(e => e.value));\n\n        const yScale = d3.scaleLinear().domain([minVal, maxVal]).range([height, 0]);\n        const dateExtent = d3.extent(lineData[0], d => d.date);\n        const xScale = d3.scaleTime().domain(dateExtent).range([0, width]);\n\n        // Draw axis.\n        svg.append('g')\n            .style('font-size', '20px')\n            .call(d3.axisLeft(yScale).tickFormat(d => `${d.toLocaleString()} EUR`));\n\n        svg.append('g')\n            .style('font-size', '20px')\n            .attr('transform', `translate(0, ${height})`)\n            .call(d3.axisBottom(xScale));\n\n        // Draw zero line.\n        svg.append('g')\n            .append('line')\n            .attr('x1', xScale(dateExtent[0]))\n            .attr('y1', yScale(0))\n            .attr('x2', xScale(dateExtent[1]))\n            .attr('y2', yScale(0))\n            .attr('stroke-width', zeroLineStrokeWidth)\n            .attr('stroke', 'black');\n\n        for (let i = 0; i < lineData.length; i++) {\n            svg.append('path')\n                .datum(lineData[i])\n                .attr('fill', 'none')\n                .attr('class', d => d.cssClass)\n                .attr('stroke-width', 3)\n                .attr(\n                    'd',\n                    d3\n                        .line()\n                        .x(d => xScale(d.date))\n                        .y(d => yScale(d.value))\n                );\n        }\n    }\n}\n\nexport default LineChart3D;\n","import React from 'react';\nimport ForecastModelSingleton from '../model/ForecastModel';\nimport { InvestmentModel } from '../model/InvestmentModel';\nimport LineChart3D from '../renderer/LineChartd3';\n\nconst STARTING_CAPITAL_IDENTIFIER = 'startingCapital';\nconst MONTHLY_INVESTMENT_IDENTIFIER = 'monthlyInvestment';\nconst TRANSACTION_COSTS_IDENTIFIER = 'transactionCosts';\nconst TRANSACTION_COSTS_TYPE_IDENTIFIER = 'transactionCostsType';\nconst SAVING_PHASE_IDENTIFIER = 'savingPhase';\nconst AGE_IDENTIFIER = 'age';\nconst TAX_FREE_AMOUNT_IDENTIFIER = 'taxFreeAmount';\nconst MONTHLY_PAYOUT_IDENTIFIER = 'monthlyPayout';\nconst LIFE_EXPECTATION = 'lifeExpectation';\n\nconst identifierToLabel = {\n    [STARTING_CAPITAL_IDENTIFIER]: 'Starting Capital',\n    [MONTHLY_INVESTMENT_IDENTIFIER]: 'Monthly Investment',\n    [TRANSACTION_COSTS_IDENTIFIER]: 'Transaction Costs',\n    [TRANSACTION_COSTS_TYPE_IDENTIFIER]: 'Fixes Amount ?',\n    [SAVING_PHASE_IDENTIFIER]: 'Saving Phase',\n    [AGE_IDENTIFIER]: 'Your Age',\n    [TAX_FREE_AMOUNT_IDENTIFIER]: 'Tax Free Amount',\n    [MONTHLY_PAYOUT_IDENTIFIER]: 'Monthly Payout',\n    [LIFE_EXPECTATION]: 'Life Expectation',\n};\n\nfunction transformInputToInt(e, caller) {\n    const intVal = parseInt(e.target.value);\n    return isNaN(intVal) ? 0 : intVal;\n}\n\nfunction transformInputToFloat(e, caller) {\n    const intVal = parseFloat(e.target.value);\n    return isNaN(intVal) ? 0 : intVal;\n}\n\nfunction transformCheckboxInput(e, caller) {\n    return !caller.props.value;\n}\n\nfunction generateCostConfig(state) {\n    if (state[TRANSACTION_COSTS_TYPE_IDENTIFIER].value) {\n        return { percentageCosts: 0.0, fixedCosts: state[TRANSACTION_COSTS_IDENTIFIER].value };\n    } else {\n        return { percentageCosts: state[TRANSACTION_COSTS_IDENTIFIER].value, fixedCosts: 0.0 };\n    }\n}\n\nclass InputForm extends React.Component {\n    constructor(props) {\n        super(props);\n        this.state = {\n            [STARTING_CAPITAL_IDENTIFIER]: { value: 10000, type: 'text', transformFunction: transformInputToInt },\n            [MONTHLY_INVESTMENT_IDENTIFIER]: { value: 100, type: 'text', transformFunction: transformInputToInt },\n            [MONTHLY_PAYOUT_IDENTIFIER]: { value: 1000, type: 'text', transformFunction: transformInputToInt },\n            [TRANSACTION_COSTS_IDENTIFIER]: { value: 0.005, type: 'text', transformFunction: transformInputToFloat },\n            [TRANSACTION_COSTS_TYPE_IDENTIFIER]: {\n                value: false,\n                type: 'checkbox',\n                transformFunction: transformCheckboxInput,\n            },\n            [SAVING_PHASE_IDENTIFIER]: { value: 40, type: 'text', transformFunction: transformInputToInt },\n            [AGE_IDENTIFIER]: { value: 30, type: 'text', transformFunction: transformInputToInt },\n            [TAX_FREE_AMOUNT_IDENTIFIER]: { value: 801, type: 'text', transformFunction: transformInputToInt },\n            [LIFE_EXPECTATION]: { value: 80, type: 'text', transformFunction: transformInputToInt },\n        };\n\n        this.ref = React.createRef();\n        this.handleChange = this.handleChange.bind(this);\n    }\n\n    handleChange(changedValue, changedStateIdentifier) {\n        this.state[changedStateIdentifier].value = changedValue;\n        this.setState(this.state);\n        console.log(`State ${changedStateIdentifier} changed value to ${changedValue}.`);\n    }\n\n    getVisualizationModel() {\n        return new InvestmentModel(\n            this.state[STARTING_CAPITAL_IDENTIFIER].value,\n            this.state[MONTHLY_INVESTMENT_IDENTIFIER].value,\n            this.state[MONTHLY_PAYOUT_IDENTIFIER].value,\n            this.state[SAVING_PHASE_IDENTIFIER].value,\n            { IBM: 1.0 },\n            {\n                taxFreeAmount: this.state[TAX_FREE_AMOUNT_IDENTIFIER].value,\n                costConfig: generateCostConfig(this.state),\n            },\n            this.state[AGE_IDENTIFIER].value,\n            this.state[LIFE_EXPECTATION].value\n        );\n    }\n\n    async componentDidMount() {\n        ForecastModelSingleton.configure('demo');\n        this.forecastModel = ForecastModelSingleton.getInstance();\n        await this.forecastModel.loadAndCacheHistoricalETFData('IBM');\n\n        new LineChart3D().render(this.getVisualizationModel().investmentSteps, this.ref.current);\n    }\n\n    componentDidUpdate() {\n        new LineChart3D().render(this.getVisualizationModel().investmentSteps, this.ref.current);\n    }\n\n    render() {\n        return (\n            <React.Fragment>\n                <form>\n                    {Object.keys(this.state).map(stateIdentifier => (\n                        <InputFormElement\n                            key={stateIdentifier}\n                            label={identifierToLabel[stateIdentifier]}\n                            value={this.state[stateIdentifier].value}\n                            type={this.state[stateIdentifier].type}\n                            onValueChange={this.handleChange}\n                            stateIdentifier={stateIdentifier}\n                            transformFunction={this.state[stateIdentifier].transformFunction}\n                        />\n                    ))}\n                </form>\n                <div ref={this.ref}></div>\n            </React.Fragment>\n        );\n    }\n}\n\nclass InputFormElement extends React.Component {\n    constructor(props) {\n        super(props);\n        this.handleChange = this.handleChange.bind(this);\n    }\n\n    handleChange(e) {\n        let newValue = e.target.value;\n        if (this.props.type === 'checkbox') {\n            newValue = !this.props.value;\n        }\n        this.props.onValueChange(this.props.transformFunction(e, this), this.props.stateIdentifier);\n    }\n\n    render() {\n        return (\n            <label>\n                {this.props.label}\n                <input type={this.props.type} value={this.props.value} onChange={this.handleChange} />\n            </label>\n        );\n    }\n}\n\nexport default InputForm;\n","import './App.css';\nimport InputForm from './components/InputForm';\n\nfunction App() {\n    return (\n        <div className=\"Input\">\n            <InputForm />\n        </div>\n    );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}