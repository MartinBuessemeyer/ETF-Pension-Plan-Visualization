{"version":3,"sources":["helpers/utils.js","model/ForecastModel.js","model/AccumulateModel.js","model/VisualizationModel.js","components/InputForm.js","App.js","reportWebVitals.js","index.js"],"names":["timeDiffIgnoreDivisor","numberOfMonthsOfAYear","calculateInflationAndDiscountedValue","value","loadHistoricalETFData","etfIdentifier","apiKey","a","d3","entry","timestamp","Date","toString","dividend","parseFloat","course","historicalData","sort","b","etfHistoricalToForecastArray","map","dateToTimestamp","date","Math","floor","getTime","ForecastModel","backCastTimeFactor","backCastTimeConstant","this","predictors","backCastTimeDate","setMonth","backCastTimestampConstant","forecastArray","firstTimestamp","lastTimestamp","length","maxTimestampBeforePredictorRepetition","history","lastTimestampToIncludeInPrediction","abs","filteredForecastArray","filter","regression","linear","_loadHistoricalDataIfNotPresent","_dateToPredictorTimestampAndDateTimestamp","predictorTimestamp","_createPredictorIfNotPresent","predict","growthRate","calculateTaxesOnDividend","dividendAmount","AccumulateModel","nextDate","newInvestmentAmount","etfIdentifierToRatio","costFunction","dividendFunction","lastYearModelValues","lastYarModelValues","values","costs","taxes","inflation","etfs","calculate","dateDiff","compoundInterestTimeFactor","getFullYear","getMonth","etfInvestmentAmount","calculateNextEtfValueAndCosts","numberOfInvestmentSteps","round","monthlyInvestmentBrutto","monthlyInvestment","gain","i","numberOfYearsPassed","totalTaxes","totalGain","max","investmentAmount","prevETFData","newEtfStartCapital","startCapital","monthlyInvestmentGain","etfDividendGain","calculateNewInvestmentOfETFAndCosts","investmentGain","investmentCosts","accumulateDividendAndTaxes","dividendGain","dividendTaxes","startGainInflationLoss","discountedNewEtfStartCapital","monthlyInvestmentInflationLoss","discountedNewMonthlyInvestment","dividendInflationLoss","discountedNewDividendGain","d3Representation","totalAmountOfNegative","d3RepresentationArray","height","yStart","yEnd","class","currentHeight","etf","push","subtractedStartCapital","Object","entries","etfRatio","getNextDate","forecastDate","intervalLengthInMonths","sumOfMonths","newMonth","newYear","VisualizationModel","savingPhaseLength","age","investmentPerPeriod","_calculateTimestampsForVisualization","_calculateAllYearModels","fadeOutYears","yearsLeft","currentYearBeginning","setFullYear","lifeExpectationDate","calculateForecastInterval","forecastBeginning","forecastEnd","dates","currentForecast","nextFutureDate","year","initialModelValues","getInitialModelValues","yearModels","previousYearValues","renderDivRef","width","svg","append","attr","console","log","document","querySelector","getBoundingClientRect","dataExtend","getD3Representation","minVal","maxVal","yScale","domain","range","xScale","xWidth","yearModel","x","currentYearClass","toDateString","split","join","data","selectAll","enter","d","style","call","STARTING_CAPITAL_IDENTIFIER","MONTHLY_INVESTMENT_IDENTIFIER","TRANSAKTION_COSTS_IDENTIFIER","SAVING_PHASE_IDENTIFIER","PAYOUT_PHASE_IDENTIFIER","PREDICT_IDENTIFIER","PREDICT_OUT_IDENTIFIER","identifierToLabel","InputForm","props","state","toISOString","slice","forecastModel","handleChange","bind","vis","IBM","amount","ref","React","createRef","changedValue","changedStateIdentifier","setState","renderVisualization","current","Fragment","keys","stateIdentifier","label","onValueChange","type","onChange","e","newDate","target","isNaN","then","Component","InputFormElement","App","className","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.87dcb782.chunk.js","sourcesContent":["import * as d3 from 'd3';\n\n// Ignore milliseconds, seconds, minutes.\nconst timeDiffIgnoreDivisor = 1000 * 60 * 60;\n\nexport const timestampIndexOfForecastArray = 0;\nexport const courseIndexOfForecastArray = 1;\nexport const numberOfMonthsOfAYear = 12;\nexport const inflationRate = 0.01;\n\nexport function calculateInflationAndDiscountedValue(value){\n    return [value * inflationRate, value * (1 - inflationRate)];\n}\n\nexport async function loadHistoricalETFData(etfIdentifier, apiKey) {\n    const historicalData = await d3.csv(\n        `https://www.alphavantage.co/query?function=TIME_SERIES_MONTHLY_ADJUSTED&symbol=${etfIdentifier}&apikey=${apiKey}&datatype=csv`,\n        entry => {\n            return {\n                timestamp: new Date(entry.timestamp.toString()),\n                dividend: parseFloat(entry['dividend amount']),\n                course: parseFloat(entry['adjusted close']),\n            };\n        }\n    );\n    historicalData.sort((a, b) => a.timestamp - b.timestamp);\n    return historicalData;\n}\n\nexport function etfHistoricalToForecastArray(historicalData) {\n    return historicalData.map(entry => [dateToTimestamp(entry.timestamp), entry.course]);\n}\n\nexport function dateToTimestamp(date) {\n    return Math.floor(date.getTime() / timeDiffIgnoreDivisor);\n}\n\nexport function timestampToDate(timestamp) {\n    return new Date(timestamp * timeDiffIgnoreDivisor);\n}\n\nexport default numberOfMonthsOfAYear;\n","import regression from 'regression';\nimport {\n    dateToTimestamp,\n    etfHistoricalToForecastArray,\n    loadHistoricalETFData,\n    timestampToDate,\n    timestampIndexOfForecastArray,\n    courseIndexOfForecastArray,\n} from '../helpers/utils';\n\nexport class ForecastModel {\n    constructor(apiKey, backCastTimeFactor = 2, backCastTimeConstant = 7) {\n        this.historicalData = {};\n        this.predictors = {};\n        this.backCastTimeFactor = backCastTimeFactor;\n        this.apiKey = apiKey;\n        const backCastTimeDate = new Date(0);\n        backCastTimeDate.setMonth(backCastTimeConstant);\n        this.backCastTimestampConstant = dateToTimestamp(backCastTimeDate);\n    }\n\n    async _loadHistoricalDataIfNotPresent(etfIdentifier) {\n        if (etfIdentifier in this.historicalData) {\n            return;\n        }\n        const historicalData = await loadHistoricalETFData(etfIdentifier);\n        const forecastArray = etfHistoricalToForecastArray(historicalData);\n        const firstTimestamp = forecastArray[0][timestampIndexOfForecastArray];\n        const lastTimestamp = forecastArray[forecastArray.length - 1][timestampIndexOfForecastArray];\n        const maxTimestampBeforePredictorRepetition =\n            lastTimestamp + (lastTimestamp - firstTimestamp) / this.backCastTimeFactor;\n        this.historicalData[etfIdentifier] = {\n            history: historicalData,\n            forecastArray: forecastArray,\n            maxTimestampBeforePredictorRepetition: maxTimestampBeforePredictorRepetition,\n        };\n    }\n\n    _createPredictorIfNotPresent(etfIdentifier, timestamp) {\n        if (!(etfIdentifier in this.predictors)) {\n            this.predictors[etfIdentifier] = {};\n        }\n        // Skip if already exists.\n        if (timestamp in this.predictors[etfIdentifier]) {\n            return;\n        }\n        const forecastArray = this.historicalData[etfIdentifier].forecastArray;\n        const lastTimestampToIncludeInPrediction =\n            forecastArray[forecastArray.length - 1][timestampIndexOfForecastArray] -\n            Math.abs(forecastArray[forecastArray.length - 1][timestampIndexOfForecastArray] - timestamp) *\n                this.backCastTimeFactor -\n            this.backCastTimestampConstant;\n        const filteredForecastArray = forecastArray.filter(\n            entry => entry[timestampIndexOfForecastArray] >= lastTimestampToIncludeInPrediction\n        );\n        this.predictors[etfIdentifier][timestamp] = regression.linear(filteredForecastArray);\n    }\n\n    _dateToPredictorTimestampAndDateTimestamp(date) {\n        const timestamp = dateToTimestamp(date);\n        return [\n            timestamp > this.maxTimestampBeforePredictorRepetition\n                ? this.maxTimestampBeforePredictorRepetition\n                : timestamp,\n            timestamp,\n        ];\n    }\n\n    async predict(etfIdentifier, date) {\n        await this._loadHistoricalDataIfNotPresent(etfIdentifier, this.apiKey);\n        const [predictorTimestamp, timestamp] = this._dateToPredictorTimestampAndDateTimestamp(date);\n        this._createPredictorIfNotPresent(etfIdentifier, predictorTimestamp);\n        return this.predictors[etfIdentifier][predictorTimestamp].predict(timestamp)[courseIndexOfForecastArray];\n    }\n}\n\nexport default ForecastModel;\n","import { numberOfMonthsOfAYear, calculateInflationAndDiscountedValue } from '../helpers/utils';\n\nconst corporateTaxRatio = 0.25;\n\nconst growthRate = 0.025;\n\nfunction calculateTaxesOnDividend(dividendAmount) {\n    return [dividendAmount * (1 - corporateTaxRatio), dividendAmount * corporateTaxRatio];\n}\n\nexport class AccumulateModel {\n    constructor(\n        date,\n        nextDate,\n        newInvestmentAmount,\n        etfIdentifierToRatio,\n        costFunction,\n        dividendFunction,\n        lastYearModelValues\n    ) {\n        this.lastYarModelValues = lastYearModelValues;\n        this.date = date;\n        this.newInvestmentAmount = newInvestmentAmount;\n        this.nextDate = nextDate;\n        this.etfIdentifierToRatio = etfIdentifierToRatio;\n        this.costFunction = costFunction;\n        this.dividendFunction = dividendFunction;\n        this.values = {\n            costs: lastYearModelValues.costs,\n            taxes: lastYearModelValues.taxes,\n            inflation: lastYearModelValues.inflation,\n            etfs: {},\n        };\n        this.calculate();\n    }\n\n    static getInitialModelValues(startCapital, etfIdentifierToRatio, costFunction) {\n        const [subtractedStartCapital, costs] = costFunction(startCapital);\n        const values = { costs: costs, taxes: 0, inflation: 0, etfs: {} };\n        for (const [etfIdentifier, etfRatio] of Object.entries(etfIdentifierToRatio)) {\n            values.etfs[etfIdentifier] = {\n                startCapital: etfRatio * subtractedStartCapital,\n                dividend: 0,\n                monthlyInvestment: 0,\n            };\n        }\n        return values;\n    }\n\n    calculate() {\n        const dateDiff = new Date(this.nextDate - this.date);\n        const compoundInterestTimeFactor =\n            dateDiff.getFullYear() - new Date(0).getFullYear() + dateDiff.getMonth() / numberOfMonthsOfAYear;\n        for (const etfIdentifier in this.lastYarModelValues.etfs) {\n            const etfInvestmentAmount = this.etfIdentifierToRatio[etfIdentifier] * this.newInvestmentAmount;\n            this.values.etfs[etfIdentifier] = {};\n            this.calculateNextEtfValueAndCosts(etfIdentifier, etfInvestmentAmount, compoundInterestTimeFactor);\n        }\n    }\n\n    calculateNewInvestmentOfETFAndCosts(etfInvestmentAmount, compoundInterestTimeFactor) {\n        const numberOfInvestmentSteps = Math.round(compoundInterestTimeFactor * numberOfMonthsOfAYear);\n        const monthlyInvestmentBrutto = etfInvestmentAmount / numberOfInvestmentSteps;\n        const [monthlyInvestment, monthlyCosts] = this.costFunction(monthlyInvestmentBrutto);\n        const costs = monthlyCosts * numberOfInvestmentSteps;\n        let gain = 0;\n        for (let i = numberOfInvestmentSteps; i > 0.0; i--) {\n            gain += growthRate * (i / numberOfMonthsOfAYear) * monthlyInvestment + monthlyInvestment;\n        }\n        return [gain, costs];\n    }\n\n    accumulateDividendAndTaxes(etfIdentifier) {\n        const numberOfYearsPassed = this.nextDate.getFullYear() - this.date.getFullYear();\n        let totalTaxes = 0;\n        let totalGain = 0;\n        for (let i = 0; i < numberOfYearsPassed; i++) {\n            const compoundInterestTimeFactor = Math.max(0, numberOfYearsPassed - 1 - i);\n            const dividendAmount = this.dividendFunction(etfIdentifier, this.date.getFullYear() + i);\n            const [gain, taxes] = calculateTaxesOnDividend(dividendAmount);\n            totalGain += gain + gain * compoundInterestTimeFactor * growthRate;\n            totalTaxes += taxes;\n        }\n        return [totalGain, totalTaxes];\n    }\n\n    calculateNextEtfValueAndCosts(etfIdentifier, investmentAmount, compoundInterestTimeFactor) {\n        const prevETFData = this.lastYarModelValues.etfs[etfIdentifier];\n        const newEtfStartCapital =\n            growthRate * compoundInterestTimeFactor * prevETFData.startCapital + prevETFData.startCapital;\n        const monthlyInvestmentGain = growthRate * compoundInterestTimeFactor * prevETFData.monthlyInvestment;\n        const etfDividendGain = growthRate * compoundInterestTimeFactor * prevETFData.dividend;\n        const [investmentGain, investmentCosts] = this.calculateNewInvestmentOfETFAndCosts(\n            investmentAmount,\n            compoundInterestTimeFactor\n        );\n        const [dividendGain, dividendTaxes] = this.accumulateDividendAndTaxes(etfIdentifier);\n        // TODO missing: increase of costs over time.\n\n        // deduce inflation from every value.\n        const [startGainInflationLoss, discountedNewEtfStartCapital] = calculateInflationAndDiscountedValue(\n            newEtfStartCapital\n        );\n        this.values.inflation += startGainInflationLoss;\n        this.values.etfs[etfIdentifier].startCapital = discountedNewEtfStartCapital;\n\n        const newMonthlyInvestment = prevETFData.monthlyInvestment + monthlyInvestmentGain + investmentGain;\n        const [monthlyInvestmentInflationLoss, discountedNewMonthlyInvestment] = calculateInflationAndDiscountedValue(\n            newMonthlyInvestment\n        );\n        this.values.inflation += monthlyInvestmentInflationLoss;\n        this.values.etfs[etfIdentifier].monthlyInvestment = discountedNewMonthlyInvestment;\n\n        const newDividendGain = prevETFData.dividend + dividendGain + etfDividendGain;\n        const [dividendInflationLoss, discountedNewDividendGain] = calculateInflationAndDiscountedValue(\n            newDividendGain\n        );\n        this.values.inflation += dividendInflationLoss;\n        this.values.etfs[etfIdentifier].dividend = discountedNewDividendGain;\n\n        this.values.costs += investmentCosts;\n        this.values.taxes += dividendTaxes;\n    }\n\n    getD3Representation() {\n        if (this.d3Representation != null) {\n            return this.d3Representation;\n        }\n        const totalAmountOfNegative = this.values.taxes + this.values.costs + this.values.inflation;\n        const d3RepresentationArray = [\n            // y extend = height, y start = upper right corner\n            { height: this.values.inflation, yStart: 0, yEnd: 0 - this.values.inflation, class: 'inflation' },\n            {\n                height: this.values.taxes,\n                yStart: -this.values.inflation,\n                yEnd: -this.values.inflation - this.values.taxes,\n                class: 'taxes',\n            },\n            {\n                height: this.values.costs,\n                yStart: -this.values.inflation - this.values.taxes,\n                yEnd: -this.values.taxes - this.values.costs - this.values.inflation,\n                class: 'costs',\n            },\n        ];\n        let currentHeight = 0;\n        for (const etfIdentifier in this.values.etfs) {\n            const etf = this.values.etfs[etfIdentifier];\n            // start capital\n            d3RepresentationArray.push({\n                height: etf.startCapital,\n                yStart: currentHeight + etf.startCapital,\n                yEnd: currentHeight,\n                class: `${etfIdentifier}_start_capital`,\n            });\n            currentHeight += etf.startCapital;\n\n            // dividend\n            d3RepresentationArray.push({\n                height: etf.dividend,\n                yStart: currentHeight + etf.dividend,\n                yEnd: currentHeight,\n                class: `${etfIdentifier}_dividend`,\n            });\n            currentHeight += etf.dividend;\n\n            // monthly Investment\n            d3RepresentationArray.push({\n                height: etf.monthlyInvestment,\n                yStart: currentHeight + etf.monthlyInvestment,\n                yEnd: currentHeight,\n                class: `${etfIdentifier}_monthly_investment`,\n            });\n            currentHeight += etf.monthlyInvestment;\n        }\n        // extend, representation\n        this.d3Representation = [[-totalAmountOfNegative, currentHeight], d3RepresentationArray];\n        return this.d3Representation;\n    }\n}\n\nexport default AccumulateModel;\n","import * as d3 from 'd3';\nimport { numberOfMonthsOfAYear } from '../helpers/utils';\nimport AccumulateModel from './AccumulateModel';\n\nfunction calculateForecastInterval(age, lifeExpectation = 80, fadeOutYears = 10) {\n    const yearsLeft = lifeExpectation - age;\n    const currentYearBeginning = new Date(0);\n    currentYearBeginning.setFullYear(new Date().getFullYear());\n    const lifeExpectationDate = new Date(0);\n    lifeExpectationDate.setFullYear(new Date().getFullYear() + yearsLeft + fadeOutYears);\n    return [currentYearBeginning, lifeExpectationDate];\n}\n\n// Calculate next date in a more complex way to avoid Date inconsistencies such as a leap year.\nfunction getNextDate(forecastDate, intervalLengthInMonths) {\n    const sumOfMonths = forecastDate.getMonth() + intervalLengthInMonths;\n    const newMonth = sumOfMonths % numberOfMonthsOfAYear;\n    const newYear = forecastDate.getFullYear() + Math.floor(sumOfMonths / numberOfMonthsOfAYear);\n    return new Date(newYear, newMonth);\n}\n\nexport class VisualizationModel {\n    constructor(\n        startCapital,\n        monthlyInvestment,\n        savingPhaseLength,\n        etfIdentifierToRatio,\n        costFunction,\n        age,\n        intervalLengthInMonths = 12\n    ) {\n        this.startCapital = startCapital;\n        this.investmentPerPeriod = monthlyInvestment * intervalLengthInMonths;\n        this.savingPhaseLength = savingPhaseLength;\n        this.etfIdentifierToRatio = etfIdentifierToRatio;\n        this.costFunction = costFunction;\n        this.age = age;\n        this.intervalLengthInMonths = intervalLengthInMonths;\n        this._calculateTimestampsForVisualization();\n        this._calculateAllYearModels();\n    }\n    _calculateTimestampsForVisualization() {\n        const [forecastBeginning, forecastEnd] = calculateForecastInterval(this.age);\n        const dates = [];\n        let currentForecast = forecastBeginning;\n        while (currentForecast <= forecastEnd) {\n            dates.push(currentForecast);\n            currentForecast = getNextDate(currentForecast, this.intervalLengthInMonths);\n        }\n        this.dates = dates;\n        this.nextFutureDate = currentForecast;\n    }\n\n    _calculateAllYearModels() {\n        const dividendFunction = year => {\n            return this.startCapital * 0.05;\n        };\n        const etfIdentifiersToAmount = {};\n        const initialModelValues = AccumulateModel.getInitialModelValues(\n            this.startCapital,\n            this.etfIdentifierToRatio,\n            this.costFunction\n        );\n        const yearModels = [\n            new AccumulateModel(\n                this.dates[0],\n                this.dates[1],\n                this.investmentPerPeriod,\n                this.etfIdentifierToRatio,\n                this.costFunction,\n                dividendFunction,\n                initialModelValues\n            ),\n        ];\n        for (let i = 0; i < this.dates.length - 1; i++) {\n            const previousYearValues = yearModels[yearModels.length - 1].values;\n            yearModels.push(\n                new AccumulateModel(\n                    this.dates[i],\n                    this.dates[i + 1],\n                    this.investmentPerPeriod,\n                    this.etfIdentifierToRatio,\n                    this.costFunction,\n                    dividendFunction,\n                    previousYearValues\n                )\n            );\n        }\n        if (this.dates.length > 1) {\n            yearModels.push(\n                new AccumulateModel(\n                    this.dates[this.dates.length - 1],\n                    this.nextFutureDate,\n                    this.investmentPerPeriod,\n                    this.etfIdentifierToRatio,\n                    this.costFunction,\n                    dividendFunction,\n                    yearModels[yearModels.length - 1].values\n                )\n            );\n            this.yearModels = yearModels;\n        }\n    }\n\n    renderVisualization(renderDivRef) {\n        const svgID = 'firstSVG';\n\n        const marginW = 100,\n            marginH = 40,\n            width = 1000,\n            height = 400;\n\n        const svg = d3\n            .select(renderDivRef)\n            .append('svg')\n            .attr('id', svgID)\n            .attr('height', '100%')\n            .attr('width', '100%')\n            .attr('viewBox', `0 0 ${width + 2 * marginW} ${height + 2 * marginH}`)\n            .append('g')\n            .attr('transform', `translate(${[marginW, marginH]})`);\n\n        /*const svgBBox = document.querySelector(`svg#${svgID}`).getBoundingClientRect();\n        const totalWidth = svgBBox.width;\n        const totalHeight = svgBBox.height;\n\n\n        const marginW = totalWidth * 0.2,\n            marginH = totalHeight * 0.1;\n        const width = totalWidth - 2 * marginW,\n            height = totalHeight - 2 * marginH;\n\n            \n            const svg = svgElement.attr('viewBox', `0 0 ${width + 2 * marginW} ${height + 2 * marginH}`)\n            .append('g')\n            .attr('transform', `translate(${[marginW, marginH]})`);*/\n\n        console.log(document.querySelector('svg').getBoundingClientRect());\n\n        console.log(width, height);\n\n        // create scales\n        const renderData = this.yearModels.map(a => a.getD3Representation());\n        const dataExtend = renderData.map(a => a[0]);\n        const minVal = d3.min(dataExtend.map(a => a[0]));\n        const maxVal = d3.max(dataExtend.map(a => a[1]));\n\n        const yScale = d3.scaleLinear().domain([minVal, maxVal]).range([height, 0]);\n\n        const xScale = d3.scaleTime().domain([this.dates[0], this.nextFutureDate]).range([0, width]);\n\n        const xWidth = (width / this.dates.length) * 0.9;\n\n        for (let i = 0; i < this.yearModels.length; i++) {\n            const yearModel = this.yearModels[i];\n            const x = yearModel.date;\n            const currentYearClass = x.toDateString().split(' ').join('_');\n            const data = yearModel.getD3Representation()[1];\n            console.log(data);\n            svg.selectAll(`rect.${currentYearClass}`)\n                .append('g')\n                .attr('class', currentYearClass)\n                .data(data)\n                .enter()\n                .append('rect')\n                .attr('x', xScale(x))\n                .attr('y', d => yScale(d.yStart))\n                .attr('width', xWidth)\n                .attr('height', d => yScale(d.yEnd) - yScale(d.yStart))\n                .attr('class', d => d.class);\n\n            svg.append('g')\n                //.attr(\"font-family\", \"sans\")\n                .style('font-size', '20px')\n                //.attr(\"transform\",\"translate(42, 2)\")\n                .call(d3.axisLeft(yScale));\n\n            svg.append('g')\n                //.attr(\"font-family\", \"sans\")\n                .style('font-size', '20px')\n                .attr('transform', `translate(0, ${height})`)\n                .call(d3.axisBottom(xScale));\n\n            svg.append('g')\n                .append('line')\n                .attr('x1', xScale(this.dates[0]))\n                .attr('y1', yScale(0))\n                .attr('x2', xScale(this.nextFutureDate))\n                .attr('y2', yScale(0))\n                .attr('stroke-width', 1)\n                .attr('stroke', 'black');\n        }\n    }\n\n    updateVisualization() {}\n\n}\n\nexport default VisualizationModel;\n","import React from 'react';\nimport ForecastModel from '../model/ForecastModel';\nimport VisualizationModel from '../model/VisualizationModel';\n\nconst STARTING_CAPITAL_IDENTIFIER = 'startingCapital';\nconst MONTHLY_INVESTMENT_IDENTIFIER = 'monthlyInvestment';\nconst TRANSAKTION_COSTS_IDENTIFIER = 'transactionCosts';\nconst SAVING_PHASE_IDENTIFIER = 'savingPhase';\nconst PAYOUT_PHASE_IDENTIFIER = 'payoutPhase';\nconst AGE_IDENTIFIER = 'age';\nconst PREDICT_IDENTIFIER = 'predict';\nconst PREDICT_OUT_IDENTIFIER = 'predictOut';\n\nconst identifierToLabel = {\n    [STARTING_CAPITAL_IDENTIFIER]: 'Starting Capital',\n    [MONTHLY_INVESTMENT_IDENTIFIER]: 'Monthly Investment',\n    [TRANSAKTION_COSTS_IDENTIFIER]: 'Transaction Costs',\n    [SAVING_PHASE_IDENTIFIER]: 'Saving Phase',\n    [PAYOUT_PHASE_IDENTIFIER]: 'Payout Phase',\n    [AGE_IDENTIFIER]: 'Your Age',\n};\n\nclass InputForm extends React.Component {\n    constructor(props) {\n        super(props);\n        this.state = {\n            [STARTING_CAPITAL_IDENTIFIER]: 10000,\n            [MONTHLY_INVESTMENT_IDENTIFIER]: 100,\n            [TRANSAKTION_COSTS_IDENTIFIER]: 5,\n            [SAVING_PHASE_IDENTIFIER]: 40,\n            [PAYOUT_PHASE_IDENTIFIER]: 20,\n            [AGE_IDENTIFIER]: 30,\n            [PREDICT_IDENTIFIER]: new Date('2021-06-01').toISOString().slice(0, 10),\n            [PREDICT_OUT_IDENTIFIER]: 0,\n        };\n        this.forecastModel = new ForecastModel('demo');\n        this.handleChange = this.handleChange.bind(this);\n\n        const costFunction = amount => {\n            return [amount - 5, 5];\n        };\n        this.vis = new VisualizationModel(10000, 100, 40, { IBM: 1.0 }, costFunction, 30);\n        console.log(this.vis);\n        this.ref = React.createRef();\n    }\n\n    handleChange(changedValue, changedStateIdentifier) {\n        this.setState({ [changedStateIdentifier]: changedValue });\n        console.log(`State ${changedStateIdentifier} changed value to ${changedValue}.`);\n    }\n\n    componentDidMount(){\n        this.vis.renderVisualization(this.ref.current);\n    }\n\n    render() {\n        return (\n            <React.Fragment>\n                <form>\n                    {Object.keys(this.state).map(stateIdentifier => (\n                        <InputFormElement\n                            key={stateIdentifier}\n                            label={identifierToLabel[stateIdentifier]}\n                            value={this.state[stateIdentifier]}\n                            onValueChange={this.handleChange}\n                            stateIdentifier={stateIdentifier}\n                        />\n                    ))}\n                </form>\n                <label>\n                    Predict Date:\n                    <input\n                        key={PREDICT_IDENTIFIER}\n                        type=\"text\"\n                        value={this.state[PREDICT_IDENTIFIER]}\n                        onChange={e => {\n                            const newDate = new Date(e.target.value);\n                            this.handleChange(e.target.value, PREDICT_IDENTIFIER);\n                            if (newDate != null && !isNaN(newDate.getTime())) {\n                                this.forecastModel\n                                    .predict('IBM', newDate)\n                                    .then(e => this.handleChange(e, PREDICT_OUT_IDENTIFIER));\n                            }\n                        }}\n                    />\n                </label>\n                <label>\n                    Prediction:\n                    <p key={PREDICT_OUT_IDENTIFIER}>{this.state[PREDICT_OUT_IDENTIFIER]}</p>\n                </label>\n                <div ref={this.ref}></div>\n            </React.Fragment>\n        );\n    }\n}\n\nclass InputFormElement extends React.Component {\n    constructor(props) {\n        super(props);\n        this.state = { value: '' };\n        this.handleChange = this.handleChange.bind(this);\n    }\n\n    handleChange(e) {\n        this.props.onValueChange(e.target.value, this.props.stateIdentifier);\n    }\n\n    render() {\n        return (\n            <label>\n                {this.props.label}\n                <input type=\"text\" value={this.props.value} onChange={this.handleChange} />\n            </label>\n        );\n    }\n}\n\nexport default InputForm;\n","import './App.css';\nimport InputForm from './components/InputForm';\n\nfunction App() {\n    return (\n        <div className=\"Input\">\n            <InputForm />\n        </div>\n    );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}