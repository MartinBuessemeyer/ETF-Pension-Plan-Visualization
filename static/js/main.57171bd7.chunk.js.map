{"version":3,"sources":["helpers/utils.js","model/ForecastModel.js","model/PartiallyCalculations.js","model/AccumulateModel.js","model/VisualizationModel.js","renderer/LineChartd3.js","components/InputForm.js","App.js","reportWebVitals.js","index.js"],"names":["timeDiffIgnoreDivisor","numberOfMonthsOfAYear","isStartOfTheYear","date","getMonth","intervalIsEndOfYear","startDate","endDate","getFullYear","roundToMoneyAmount","amount","Math","round","loadHistoricalETFData","etfIdentifier","apiKey","a","d3","entry","Date","timestamp","toString","dividend","parseFloat","course","historicalData","sort","b","etfHistoricalToCourseForecastArray","map","dateToTimestamp","etfHistoricalToDividendForecastArray","currentYear","dividendForecastArray","forEach","length","push","floor","getTime","ForecastModelSingleton","this","coursePredictors","dividendPredictors","courseForecastArray","maxTimestampBeforeCoursePredictorRepetition","_calculateMaxTimestampBeforePredictorRepetition","maxYearBeforeDividendPredictorRepetition","history","forecastArray","lastTimestampToIncludeInPrediction","abs","backCastTimeFactor","backCastTimestampConstant","filteredForecastArray","filter","regression","linear","order","precision","year","lastYearToIncludeInPrediction","_courseDateToPredictorTimestampAndDateTimestamp","predictorTimestamp","_createCoursePredictorIfNotPresent","predict","predictorYear","_dividendYearToPredictorYear","_createDividendPredictorIfNotPresent","max","backCastTimeConstant","backCastTimeDate","setMonth","instance","getInstance","firstTimestamp","lastTimestamp","corporateTaxRatio","calculatePrizeGain","forecastModel","startCourse","predictCourse","calculateCosts","costConfiguration","costs","percentageCosts","fixedCosts","calculateTaxesOnThesaurierer","vorabpauschale","taxFreeAmount","taxAmount","subtractTaxFreeGain","leftoverToApplyTaxes","leftoverTaxFreeAmount","dateTupleIndex","etfTupleIndex","AccumulateModel","initialDate","nextDate","newInvestmentAmount","etfIdentifierToRatio","lastYearModelValues","taxFreeAmountForAYear","taxes","etfs","yearBeginningCapital","totalAmount","investedMoney","investmentStepsOfThisYear","alreadyPaidTaxesForAmount","calculate","newInvestmentAmountNetto","etfInvestmentAmount","calculateNextEtfValueAndCosts","totalGain","gain","investmentAmountAtBeginningOfTheYear","accumulatedBasicRate","currentDate","numberOfMonthsLeftThisYear","min","calculateVorabpauschale","inflation","value","timeFactor","pow","calculateInflation","investmentAmount","prevETFData","etfPrizeGain","capital","etfDividendGain","_calculateNewInvestmentOfETFAndCosts","investment","investmentGain","investmentCosts","dividendPayout","predictDividend","calculateNewDividendPayout","totalGainBrutto","etfValueBrutto","numberOfInvestmentSteps","monthlyInvestmentNetto","invested","i","_addInvestmentStep","dateIndex","findIndex","e","startCapital","subtractedStartCapital","values","investmentSteps","Object","entries","etfRatio","getNextDate","forecastDate","intervalLengthInMonths","sumOfMonths","newMonth","newYear","VisualizationModel","monthlyInvestment","savingPhaseLength","age","Number","isInteger","investmentPerPeriod","_calculateTimestampsForVisualization","_calculateAllYearModels","fadeOutYears","yearsLeft","currentYearBeginning","setFullYear","lifeExpectationDate","calculateForecastInterval","forecastBeginning","forecastEnd","dates","currentForecast","nextFutureDate","yearModels","getInitialModelValues","previousYearValues","renderDivRef","width","svg","append","attr","height","renderData","getD3Representation","dataExtend","extent","minVal","maxVal","yScale","domain","range","xScale","xWidth","yearModel","x","currentYearClass","toDateString","split","join","data","bars","selectAll","enter","d","yStart","yEnd","class","style","call","tickFormat","toLocaleString","moneyDataArray","unshift","money","datum","y","LineChart3D","visualizationModel","innerHTML","dataToIndex","currentIdx","capitalIdentifier","dividendIdentifier","lineData","heightOffset","cssClass","STARTING_CAPITAL_IDENTIFIER","MONTHLY_INVESTMENT_IDENTIFIER","TRANSACTION_COSTS_IDENTIFIER","TRANSACTION_COSTS_TYPE_IDENTIFIER","SAVING_PHASE_IDENTIFIER","PAYOUT_PHASE_IDENTIFIER","AGE_IDENTIFIER","TAX_FREE_AMOUNT_IDENTIFIER","identifierToLabel","InputForm","props","state","type","ref","React","createRef","handleChange","bind","changedValue","changedStateIdentifier","setState","console","log","IBM","configure","loadAndCacheHistoricalETFData","render","getVisualizationModel","current","Fragment","keys","stateIdentifier","label","onValueChange","Component","InputFormElement","newValue","target","onChange","App","className","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.57171bd7.chunk.js","sourcesContent":["import * as d3 from 'd3';\n\n// Ignore milliseconds, seconds, minutes.\nconst timeDiffIgnoreDivisor = 1000 * 60 * 60 * 24;\n\nexport const timestampIndexOfForecastArray = 0;\nexport const courseIndexOfForecastArray = 1;\nexport const numberOfMonthsOfAYear = 12;\nexport const inflationRate = 0.01;\n\nexport function isStartOfTheYear(date) {\n    return date.getMonth() === 0;\n}\n\nexport function intervalIsEndOfYear(startDate, endDate){\n    return startDate.getFullYear() < endDate.getFullYear();\n}\n\nexport function roundToMoneyAmount(amount){\n    return Math.round(amount * 100.0) / 100.0;\n}\n\nexport async function loadHistoricalETFData(etfIdentifier, apiKey) {\n    const historicalData = await d3.csv(\n        `https://www.alphavantage.co/query?function=TIME_SERIES_MONTHLY_ADJUSTED&symbol=${etfIdentifier}&apikey=${apiKey}&datatype=csv`,\n        entry => {\n            return {\n                date: new Date(entry.timestamp.toString()),\n                dividend: parseFloat(entry['dividend amount']),\n                course: parseFloat(entry['adjusted close']),\n            };\n        }\n    );\n    historicalData.sort((a, b) => a.date - b.date);\n    return historicalData;\n}\n\nexport function etfHistoricalToCourseForecastArray(historicalData) {\n    return historicalData.map(entry => [dateToTimestamp(entry.date), entry.course]);\n}\n\n// Requires sorted historical data. Note it is sorted by default. Do not change the order.\nexport function etfHistoricalToDividendForecastArray(historicalData) {\n    let currentYear = historicalData[0].date.getFullYear();\n    const dividendForecastArray = [[currentYear, 0]];\n    historicalData.forEach(entry => {\n        if(entry.date.getFullYear() === currentYear) {\n            dividendForecastArray[dividendForecastArray.length - 1][courseIndexOfForecastArray] += entry.dividend;\n        }\n        else {\n            currentYear = entry.date.getFullYear();\n            dividendForecastArray.push([currentYear, entry.dividend]);\n        }\n    });\n    dividendForecastArray.sort((a, b) => a[timestampIndexOfForecastArray] - b[timestampIndexOfForecastArray]);\n    return dividendForecastArray;\n}\n\nexport function dateToTimestamp(date) {\n    return Math.floor(date.getTime() / timeDiffIgnoreDivisor);\n}\n\nexport function timestampToDate(timestamp) {\n    return new Date(timestamp * timeDiffIgnoreDivisor);\n}\n\nexport default numberOfMonthsOfAYear;\n","import regression from 'regression';\nimport {\n    dateToTimestamp,\n    etfHistoricalToCourseForecastArray,\n    etfHistoricalToDividendForecastArray,\n    loadHistoricalETFData,\n    timestampToDate,\n    timestampIndexOfForecastArray,\n    courseIndexOfForecastArray,\n} from '../helpers/utils';\n\n// USAGE: first call configure to set required static vars. Then the singleton can be accessed via getInstance. Never call the Constructor on your own.\n// Always call loadAndCacheHistoricalETFData of an etf before calling predict on that etf.\nexport class ForecastModelSingleton {\n    static instance = null;\n    static apiKey = null;\n    static backCastTimeConstant = null;\n    static backCastTimeFactor = null;\n\n    // DO NOT CALL. USE getInstance()\n    constructor() {\n        this.historicalData = {};\n        this.coursePredictors = {};\n        this.dividendPredictors = {};\n    }\n\n    static configure(apiKey, backCastTimeFactor = 2, backCastTimeConstant = 7) {\n        ForecastModelSingleton.apiKey = apiKey;\n        ForecastModelSingleton.backCastTimeFactor = backCastTimeFactor;\n\n        const backCastTimeDate = new Date(0);\n        backCastTimeDate.setMonth(backCastTimeConstant);\n        ForecastModelSingleton.backCastTimestampConstant = dateToTimestamp(backCastTimeDate);\n\n        // reset predictors if present.\n        if (ForecastModelSingleton.instance != null) {\n            const instance = ForecastModelSingleton.getInstance();\n            for (const etfIdentifier in instance.coursePredictors) {\n                instance.coursePredictors[etfIdentifier] = {\n                    maxTimestampBeforeCoursePredictorRepetition: ForecastModelSingleton._calculateMaxTimestampBeforePredictorRepetition(\n                        instance.historicalData[etfIdentifier].courseForecastArray\n                    ),\n                };\n            }\n            for (const etfIdentifier in instance.dividendPredictors) {\n                instance.dividendPredictors[etfIdentifier] = {\n                    maxYearBeforeDividendPredictorRepetition: ForecastModelSingleton._calculateMaxTimestampBeforePredictorRepetition(\n                        instance.historicalData[etfIdentifier].dividendForecastArray\n                    ),\n                };\n            }\n        }\n    }\n\n    static getInstance() {\n        if (ForecastModelSingleton.instance == null) {\n            ForecastModelSingleton.instance = new ForecastModelSingleton();\n        }\n        return ForecastModelSingleton.instance;\n    }\n\n    static _calculateMaxTimestampBeforePredictorRepetition(forecastArray) {\n        const firstTimestamp = forecastArray[0][timestampIndexOfForecastArray];\n        const lastTimestamp = forecastArray[forecastArray.length - 1][timestampIndexOfForecastArray];\n        return lastTimestamp + (lastTimestamp - firstTimestamp) / ForecastModelSingleton.backCastTimeFactor;\n    }\n\n    async loadAndCacheHistoricalETFData(etfIdentifier) {\n        if (etfIdentifier in this.historicalData) {\n            return;\n        }\n        const historicalData = await loadHistoricalETFData(etfIdentifier);\n\n        const courseForecastArray = etfHistoricalToCourseForecastArray(historicalData);\n        const maxTimestampBeforeCoursePredictorRepetition = ForecastModelSingleton._calculateMaxTimestampBeforePredictorRepetition(\n            courseForecastArray\n        );\n\n        const dividendForecastArray = etfHistoricalToDividendForecastArray(historicalData);\n        const maxYearBeforeDividendPredictorRepetition = ForecastModelSingleton._calculateMaxTimestampBeforePredictorRepetition(\n            dividendForecastArray\n        );\n\n        this.historicalData[etfIdentifier] = {\n            history: historicalData,\n            courseForecastArray: courseForecastArray,\n            dividendForecastArray: dividendForecastArray,\n        };\n        this.coursePredictors[etfIdentifier] = {\n            maxTimestampBeforeCoursePredictorRepetition: maxTimestampBeforeCoursePredictorRepetition,\n        };\n        this.dividendPredictors[etfIdentifier] = {\n            maxYearBeforeDividendPredictorRepetition: maxYearBeforeDividendPredictorRepetition,\n        };\n    }\n\n    _createCoursePredictorIfNotPresent(etfIdentifier, timestamp) {\n        // Skip if already exists.\n        if (timestamp in this.coursePredictors[etfIdentifier]) {\n            return;\n        }\n        const forecastArray = this.historicalData[etfIdentifier].courseForecastArray;\n        const lastTimestampToIncludeInPrediction =\n            forecastArray[forecastArray.length - 1][timestampIndexOfForecastArray] -\n            Math.abs(forecastArray[forecastArray.length - 1][timestampIndexOfForecastArray] - timestamp) *\n                ForecastModelSingleton.backCastTimeFactor -\n            ForecastModelSingleton.backCastTimestampConstant;\n        const filteredForecastArray = forecastArray.filter(\n            entry => entry[timestampIndexOfForecastArray] >= lastTimestampToIncludeInPrediction\n        );\n        this.coursePredictors[etfIdentifier][timestamp] = regression.linear(filteredForecastArray, {\n            order: 2,\n            precision: 20,\n        });\n    }\n\n    _courseDateToPredictorTimestampAndDateTimestamp(date, etfIdentifier) {\n        const timestamp = dateToTimestamp(date);\n        return [\n            timestamp > this.coursePredictors[etfIdentifier].maxTimestampBeforeCoursePredictorRepetition\n                ? this.coursePredictors[etfIdentifier].maxTimestampBeforeCoursePredictorRepetition\n                : timestamp,\n            timestamp,\n        ];\n    }\n\n    _createDividendPredictorIfNotPresent(etfIdentifier, year) {\n        // Skip if already exists.\n        if (year in this.dividendPredictors[etfIdentifier]) {\n            return;\n        }\n        const forecastArray = this.historicalData[etfIdentifier].dividendForecastArray;\n        const lastYearToIncludeInPrediction =\n            forecastArray[forecastArray.length - 1][timestampIndexOfForecastArray] -\n            Math.abs(forecastArray[forecastArray.length - 1][timestampIndexOfForecastArray] - year) *\n                ForecastModelSingleton.backCastTimeFactor -\n            ForecastModelSingleton.backCastTimestampConstant;\n        const filteredForecastArray = forecastArray.filter(\n            entry => entry[timestampIndexOfForecastArray] >= lastYearToIncludeInPrediction\n        );\n        this.dividendPredictors[etfIdentifier][year] = regression.linear(filteredForecastArray, {\n            order: 2,\n            precision: 20,\n        });\n    }\n\n    _dividendYearToPredictorYear(etfIdentifier, year) {\n        return this.dividendPredictors[etfIdentifier].maxYearBeforeDividendPredictorRepetition < year\n            ? this.dividendPredictors[etfIdentifier].maxYearBeforeDividendPredictorRepetition\n            : year;\n    }\n\n    predictCourse(etfIdentifier, date) {\n        if (!(etfIdentifier in this.coursePredictors)) {\n            throw `First call loadHistoricalDataIfNotPresent() before predicting: ${etfIdentifier}`;\n        }\n        const [predictorTimestamp, timestamp] = this._courseDateToPredictorTimestampAndDateTimestamp(\n            date,\n            etfIdentifier\n        );\n        this._createCoursePredictorIfNotPresent(etfIdentifier, predictorTimestamp);\n        return this.coursePredictors[etfIdentifier][predictorTimestamp].predict(timestamp)[courseIndexOfForecastArray];\n    }\n\n    predictDividend(etfIdentifier, year) {\n        if (!(etfIdentifier in this.dividendPredictors)) {\n            throw `First call loadHistoricalDataIfNotPresent() before predicting: ${etfIdentifier}`;\n        }\n        const predictorYear = this._dividendYearToPredictorYear(etfIdentifier, year);\n        this._createDividendPredictorIfNotPresent(etfIdentifier, predictorYear);\n        return Math.max(\n            0,\n            this.dividendPredictors[etfIdentifier][predictorYear].predict(year)[courseIndexOfForecastArray]\n        );\n    }\n}\n\nexport default ForecastModelSingleton;\n","import { numberOfMonthsOfAYear, intervalIsEndOfYear, roundToMoneyAmount } from '../helpers/utils';\nimport { ForecastModelSingleton } from '../model/ForecastModel';\nimport { dateTupleIndex, etfTupleIndex } from '../model/AccumulateModel';\n\nconst corporateTaxRatio = 0.26375;\nconst basicRateOfInterest = 0.015;\nconst inflationRate = 0.01;\n\nexport function calculateInflation(value, initialDate, endDate) {\n    // TODO predict inflationRate??? if so how should I calculate it?\n    const timeFactor =\n        endDate.getFullYear() -\n        initialDate.getFullYear() +\n        (endDate.getMonth() - initialDate.getMonth()) / numberOfMonthsOfAYear;\n    return value - value * Math.pow(1 - inflationRate, timeFactor);\n}\n\nexport function calculatePrizeGain(amount, startDate, endDate, etfIdentifier) {\n    const forecastModel = ForecastModelSingleton.getInstance();\n    const startCourse = forecastModel.predictCourse(etfIdentifier, startDate);\n    const endCourse = forecastModel.predictCourse(etfIdentifier, endDate);\n    const courseChangeRatio = endCourse / startCourse;\n    return roundToMoneyAmount(amount * courseChangeRatio - amount);\n}\n\nexport function calculateNewDividendPayout(etfIdentifier, startDate, endDate) {\n    // Only pay out dividend if a year has passed.\n    if (intervalIsEndOfYear(startDate, endDate)) {\n        // TODO look up the dividend value definition.\n        const forecastModel = ForecastModelSingleton.getInstance();\n        return roundToMoneyAmount(forecastModel.predictDividend(etfIdentifier, startDate.getFullYear()));\n    }\n    return 0;\n}\n\nexport function calculateCosts(amount, costConfiguration) {\n    const costs = amount * costConfiguration.percentageCosts + costConfiguration.fixedCosts;\n    return [amount - costs, costs];\n}\n\nexport function subtractTaxFreeGain(taxAmount, taxFreeAmount) {\n    const leftoverTaxes = Math.max(0, taxAmount - taxFreeAmount);\n    const leftoverTaxFreeAmount = Math.max(0, taxFreeAmount - taxAmount);\n    return [leftoverTaxes, leftoverTaxFreeAmount];\n}\n\nexport function calculateVorabpauschale(investmentStepsOfThisYear, gain, investmentAmountAtBeginningOfTheYear) {\n    // TODO basicRateOfInterest prediction???\n    // No taxes if no gain.\n    if (gain <= 0) {\n        return 0;\n    }\n    let accumulatedBasicRate = investmentAmountAtBeginningOfTheYear;\n    for (const entry of investmentStepsOfThisYear) {\n        const currentDate = entry[dateTupleIndex];\n        const numberOfMonthsLeftThisYear = numberOfMonthsOfAYear - currentDate.getMonth();\n        for (const etfIdentifier in entry[etfTupleIndex]) {\n            accumulatedBasicRate +=\n                (entry[etfTupleIndex][etfIdentifier] * numberOfMonthsLeftThisYear) / numberOfMonthsOfAYear;\n        }\n    }\n    return Math.min(accumulatedBasicRate * 0.7 * basicRateOfInterest, gain);\n}\n\nexport function calculateTaxesOnThesaurierer(vorabpauschale, taxFreeAmount, startDate, endDate) {\n    if (!intervalIsEndOfYear(startDate, endDate)) {\n        return [0, taxFreeAmount];\n    }\n    const [leftoverToApplyTaxes, leftoverTaxFreeAmount] = subtractTaxFreeGain(vorabpauschale, taxFreeAmount);\n    const taxAmount = calculateTaxesOnAmount(leftoverToApplyTaxes);\n    return [taxAmount, leftoverTaxFreeAmount];\n}\n\nexport function calculateTaxesOnAmount(amount) {\n    return amount * 0.7 * corporateTaxRatio;\n}\n","import { isStartOfTheYear, numberOfMonthsOfAYear } from '../helpers/utils';\nimport {\n    calculatePrizeGain,\n    calculateNewDividendPayout,\n    calculateTaxesOnThesaurierer,\n    calculateCosts,\n    calculateInflation,\n    calculateVorabpauschale,\n} from './PartiallyCalculations';\n\n\nexport const dateTupleIndex = 0;\nexport const etfTupleIndex = 1;\n\nexport class AccumulateModel {\n    constructor(\n        initialDate,\n        date,\n        nextDate,\n        newInvestmentAmount,\n        etfIdentifierToRatio,\n        costConfiguration,\n        lastYearModelValues,\n        taxFreeAmountForAYear\n    ) {\n        this.initialDate = initialDate; // required for inflation later on.\n        this.lastYearModelValues = lastYearModelValues;\n        this.startDate = date;\n        this.newInvestmentAmount = newInvestmentAmount;\n        this.endDate = nextDate;\n        this.etfIdentifierToRatio = etfIdentifierToRatio;\n        this.costConfiguration = costConfiguration;\n        this.costs = lastYearModelValues.costs;\n        this.taxes = lastYearModelValues.taxes;\n        this.etfs = {};\n        this.yearBeginningCapital = isStartOfTheYear(this.startDate)\n            ? lastYearModelValues.totalAmount\n            : lastYearModelValues.yearBeginningCapital;\n        this.totalAmount = 0;\n        this.investedMoney = lastYearModelValues.investedMoney + newInvestmentAmount;\n        this.leftoverTaxFreeAmount = isStartOfTheYear(this.startDate)\n            ? taxFreeAmountForAYear\n            : lastYearModelValues.leftoverTaxFreeAmount;\n        this.investmentStepsOfThisYear = isStartOfTheYear(this.startDate) ? [] : lastYearModelValues.investmentStepsOfThisYear;\n        this.alreadyPaidTaxesForAmount = 0;\n        this.calculate();\n    }\n\n    static getInitialModelValues(startCapital, etfIdentifierToRatio, costConfiguration, taxFreeAmount, initialDate) {\n        const [subtractedStartCapital, costs] = calculateCosts(startCapital, costConfiguration);\n        const values = {\n            costs: costs,\n            taxes: 0,\n            inflation: 0,\n            investedMoney: startCapital,\n            etfs: {},\n            yearBeginningCapital: subtractedStartCapital,\n            totalAmount: subtractedStartCapital,\n            leftoverTaxFreeAmount: taxFreeAmount,\n            startDate: initialDate,\n            endDate: initialDate,\n            investmentSteps: [[initialDate, {}]],\n        };\n        for (const [etfIdentifier, etfRatio] of Object.entries(etfIdentifierToRatio)) {\n            values.etfs[etfIdentifier] = {\n                capital: etfRatio * subtractedStartCapital,\n                dividend: 0,\n            };\n            values.investmentSteps[0][dateTupleIndex][etfIdentifier] = etfRatio * subtractedStartCapital;\n        }\n        return values;\n    }\n\n    calculate() {\n        let newInvestmentAmountNetto = 0;\n        for (const etfIdentifier in this.lastYearModelValues.etfs) {\n            const etfInvestmentAmount = this.etfIdentifierToRatio[etfIdentifier] * this.newInvestmentAmount;\n            this.etfs[etfIdentifier] = {};\n            newInvestmentAmountNetto += this.calculateNextEtfValueAndCosts(etfIdentifier, etfInvestmentAmount);\n        }\n        const totalGain = this.totalAmount - this.yearBeginningCapital - newInvestmentAmountNetto;\n        const vorabpauschale = calculateVorabpauschale(this.investmentStepsOfThisYear, totalGain, this.yearBeginningCapital);\n        const [taxes, leftoverTaxFreeAmount] = calculateTaxesOnThesaurierer(\n            vorabpauschale,\n            this.leftoverTaxFreeAmount,\n            this.startDate,\n            this.endDate\n        );\n        this.alreadyPaidTaxesForAmount = vorabpauschale;\n        this.taxes += taxes;\n        this.leftoverTaxFreeAmount = leftoverTaxFreeAmount;\n        this.inflation = calculateInflation(this.totalAmount, this.initialDate, this.endDate);\n    }\n\n    calculateNextEtfValueAndCosts(etfIdentifier, investmentAmount) {\n        const prevETFData = this.lastYearModelValues.etfs[etfIdentifier];\n        const etfPrizeGain = calculatePrizeGain(prevETFData.capital, this.startDate, this.endDate, etfIdentifier);\n        const etfDividendGain = calculatePrizeGain(prevETFData.dividend, this.startDate, this.endDate, etfIdentifier);\n        const [investment, investmentGain, investmentCosts] = this._calculateNewInvestmentOfETFAndCosts(\n            investmentAmount,\n            etfIdentifier,\n        );\n        const dividendPayout = calculateNewDividendPayout(etfIdentifier, this.startDate, this.endDate);\n        const totalGainBrutto = etfPrizeGain + etfDividendGain + investmentGain + dividendPayout;\n        const etfValueBrutto = prevETFData.capital + totalGainBrutto + investment;\n\n        this.etfs[etfIdentifier].capital = etfValueBrutto;\n        this.etfs[etfIdentifier].dividend = prevETFData.dividend + dividendPayout + etfDividendGain;\n\n        this.totalAmount += etfValueBrutto;\n        this.costs += investmentCosts;\n        return investment;\n    }\n\n    _calculateNewInvestmentOfETFAndCosts(etfInvestmentAmount, etfIdentifier) {\n        const numberOfInvestmentSteps =\n            (this.endDate.getFullYear() - this.startDate.getFullYear()) * numberOfMonthsOfAYear +\n            this.endDate.getMonth() -\n            this.startDate.getMonth();\n        const monthlyInvestmentBrutto = etfInvestmentAmount / numberOfInvestmentSteps;\n        const [monthlyInvestmentNetto, monthlyCosts] = calculateCosts(monthlyInvestmentBrutto, this.costConfiguration);\n        const costs = monthlyCosts * numberOfInvestmentSteps;\n        let invested = monthlyInvestmentNetto * numberOfInvestmentSteps;\n        let gain = 0;\n        for (let i = numberOfInvestmentSteps; i > 0.0; i--) {\n            const currentDate = new Date(this.startDate);\n            currentDate.setMonth(currentDate.getMonth() + i);\n            gain += calculatePrizeGain(monthlyInvestmentNetto, currentDate, this.endDate, etfIdentifier);\n            this._addInvestmentStep(monthlyInvestmentNetto, etfIdentifier, currentDate);\n        }\n        return [invested, gain, costs];\n    }\n\n    _addInvestmentStep(amount, etfIdentifier, date = null) {\n        if (date == null) {\n            date = this.startDate;\n        }\n        let dateIndex = this.investmentStepsOfThisYear.findIndex(e => e[0] == date);\n        if (dateIndex < 0){\n            dateIndex = this.investmentStepsOfThisYear.length;\n            this.investmentStepsOfThisYear.push([date, {}])\n        }\n        if (etfIdentifier in this.investmentStepsOfThisYear[dateIndex]) {\n            this.investmentStepsOfThisYear[dateIndex][etfTupleIndex][etfIdentifier] += amount;\n        } else {\n            this.investmentStepsOfThisYear[dateIndex][etfTupleIndex][etfIdentifier] = amount;\n        }\n    }\n}\n\nexport default AccumulateModel;\n","import * as d3 from 'd3';\nimport { numberOfMonthsOfAYear } from '../helpers/utils';\nimport AccumulateModel from './AccumulateModel';\n\nfunction calculateForecastInterval(age, lifeExpectation = 80, fadeOutYears = 10) {\n    const yearsLeft = lifeExpectation - age;\n    const currentYearBeginning = new Date(0);\n    currentYearBeginning.setFullYear(new Date().getFullYear());\n    const lifeExpectationDate = new Date(0);\n    lifeExpectationDate.setFullYear(new Date().getFullYear() + yearsLeft + fadeOutYears);\n    return [currentYearBeginning, lifeExpectationDate];\n}\n\n// Calculate next date in a more complex way to avoid Date inconsistencies such as a leap year.\nfunction getNextDate(forecastDate, intervalLengthInMonths) {\n    const sumOfMonths = forecastDate.getMonth() + intervalLengthInMonths;\n    const newMonth = sumOfMonths % numberOfMonthsOfAYear;\n    const newYear = forecastDate.getFullYear() + Math.floor(sumOfMonths / numberOfMonthsOfAYear);\n    return new Date(newYear, newMonth);\n}\n\nexport class VisualizationModel {\n    constructor(\n        startCapital,\n        monthlyInvestment,\n        savingPhaseLength,\n        etfIdentifierToRatio,\n        costConfiguration,\n        age,\n        taxFreeAmount,\n        intervalLengthInMonths = numberOfMonthsOfAYear\n    ) {\n        if (!Number.isInteger(intervalLengthInMonths / numberOfMonthsOfAYear)) {\n            throw `currently only month lengths that are a factor of ${numberOfMonthsOfAYear} are allowed.`;\n        }\n        this.taxFreeAmount = taxFreeAmount;\n        this.startCapital = startCapital;\n        this.investmentPerPeriod = monthlyInvestment * intervalLengthInMonths;\n        this.savingPhaseLength = savingPhaseLength;\n        this.etfIdentifierToRatio = etfIdentifierToRatio;\n        this.costConfiguration = costConfiguration;\n        this.age = age;\n        this.intervalLengthInMonths = intervalLengthInMonths;\n        this._calculateTimestampsForVisualization();\n        this._calculateAllYearModels();\n    }\n    _calculateTimestampsForVisualization() {\n        const [forecastBeginning, forecastEnd] = calculateForecastInterval(this.age);\n        const dates = [];\n        let currentForecast = forecastBeginning;\n        while (currentForecast <= forecastEnd) {\n            dates.push(currentForecast);\n            currentForecast = getNextDate(currentForecast, this.intervalLengthInMonths);\n        }\n        this.dates = dates;\n        this.nextFutureDate = currentForecast;\n    }\n\n    _calculateAllYearModels() {\n        const yearModels = [AccumulateModel.getInitialModelValues(\n            this.startCapital,\n            this.etfIdentifierToRatio,\n            this.costConfiguration,\n            this.taxFreeAmount,\n            this.dates[0]\n        )];\n        for (let i = 0; i < this.dates.length - 1; i++) {\n            const previousYearValues = yearModels[yearModels.length - 1];\n            yearModels.push(\n                new AccumulateModel(\n                    this.dates[0],\n                    this.dates[i],\n                    this.dates[i + 1],\n                    this.investmentPerPeriod,\n                    this.etfIdentifierToRatio,\n                    this.costConfiguration,\n                    previousYearValues,\n                    this.taxFreeAmount,\n                )\n            );\n        }\n        if (this.dates.length > 1) {\n            yearModels.push(\n                new AccumulateModel(\n                    this.dates[0],\n                    this.dates[this.dates.length - 1],\n                    this.nextFutureDate,\n                    this.investmentPerPeriod,\n                    this.etfIdentifierToRatio,\n                    this.costConfiguration,\n                    yearModels[yearModels.length - 1],\n                    this.taxFreeAmount\n                )\n            );\n            this.yearModels = yearModels;\n        }\n    }\n\n    renderVisualization(renderDivRef) {\n        const svgID = 'firstSVG';\n        const investedMoneyLineID = 'investedMoney';\n\n        const marginW = 150,\n            marginH = 40,\n            width = 1000,\n            height = 400;\n\n        const zeroLineStrokeWidth = 3;\n\n        const svg = d3\n            .select(renderDivRef)\n            .append('svg')\n            .attr('id', svgID)\n            .attr('height', '100%')\n            .attr('width', '100%')\n            .attr('viewBox', `0 0 ${width + 2 * marginW} ${height + 2 * marginH}`)\n            .append('g')\n            .attr('transform', `translate(${[marginW, marginH]})`);\n\n        // create scales\n        const renderData = this.yearModels.map(a => a.getD3Representation());\n        const dataExtend = renderData.map(a => a.extent);\n        const minVal = d3.min(dataExtend.map(a => a[0]));\n        const maxVal = d3.max(dataExtend.map(a => a[1]));\n\n        const yScale = d3.scaleLinear().domain([minVal, maxVal]).range([height, 0]);\n\n        const xScale = d3.scaleTime().domain([this.dates[0], this.nextFutureDate]).range([0, width]);\n\n        const xWidth = (width / this.dates.length) * 0.9;\n\n        for (let i = 0; i < this.yearModels.length; i++) {\n            const yearModel = this.yearModels[i];\n            const x = yearModel.date;\n            const currentYearClass = x.toDateString().split(' ').join('_');\n            const data = yearModel.getD3Representation().bars;\n            svg.selectAll(`rect.${currentYearClass}`)\n                .append('g')\n                .attr('class', currentYearClass)\n                .data(data)\n                .enter()\n                .append('rect')\n                .attr('x', xScale(x))\n                .attr('y', d => yScale(d.yStart))\n                .attr('width', xWidth)\n                .attr('height', d => yScale(d.yEnd) - yScale(d.yStart))\n                .attr('class', d => d.class);\n        }\n        // Draw axis\n        svg.append('g')\n            .style('font-size', '20px')\n            .call(d3.axisLeft(yScale).tickFormat(d => `${d.toLocaleString()} EUR`));\n\n        svg.append('g')\n            .style('font-size', '20px')\n            .attr('transform', `translate(0, ${height})`)\n            .call(d3.axisBottom(xScale));\n\n        svg.append('g')\n            .append('line')\n            .attr('x1', xScale(this.dates[0]))\n            .attr('y1', yScale(0))\n            .attr('x2', xScale(this.nextFutureDate))\n            .attr('y2', yScale(0))\n            .attr('stroke-width', zeroLineStrokeWidth)\n            .attr('stroke', 'black');\n\n        // Draw invested Money line.\n        const moneyDataArray = renderData.map(e => e.investedMoney);\n        moneyDataArray.unshift({ date: this.dates[0], money: this.startCapital });\n\n        svg.append('path')\n            .datum(moneyDataArray)\n            .attr('fill', 'none')\n            .attr('id', investedMoneyLineID)\n            .attr('stroke-width', 3)\n            .attr(\n                'd',\n                d3\n                    .line()\n                    .x(d => xScale(d.date))\n                    .y(d => yScale(d.money))\n            );\n    }\n\n    updateVisualization() {}\n}\n\nexport default VisualizationModel;\n","import * as d3 from 'd3';\n\nexport class LineChart3D {\n    render(visualizationModel, renderDivRef) {\n        const svgID = 'firstSVG';\n        const investedMoneyLineID = 'investedMoney';\n\n        const marginW = 150,\n            marginH = 40,\n            width = 1000,\n            height = 400;\n\n        const zeroLineStrokeWidth = 3;\n\n        // Reset diagram by deletion.\n        renderDivRef.innerHTML = '';\n\n        const svg = d3\n            .select(renderDivRef)\n            .append('svg')\n            .attr('id', svgID)\n            .attr('height', '100%')\n            .attr('width', '100%')\n            .attr('viewBox', `0 0 ${width + 2 * marginW} ${height + 2 * marginH}`)\n            .append('g')\n            .attr('transform', `translate(${[marginW, marginH]})`);\n\n        // create line array\n\n        const dataToIndex = {\n            costs: 0,\n            taxes: 1,\n            inflation: 2,\n        };\n        let currentIdx = 3;\n        const capitalIdentifier = 'capital';\n        const dividendIdentifier = 'dividend';\n        for (const etfIdentifier in visualizationModel.etfIdentifierToRatio) {\n            dataToIndex[etfIdentifier + dividendIdentifier] = currentIdx++;\n            dataToIndex[etfIdentifier + capitalIdentifier] = currentIdx++;\n        }\n\n        const lineData = [];\n        for (let i = 0; i < currentIdx; i++) {\n            lineData.push([]);\n        }\n        for (const yearModel of visualizationModel.yearModels) {\n            lineData[dataToIndex.costs].push({ value: -yearModel.costs, date: yearModel.endDate });\n            lineData[dataToIndex.taxes].push({\n                value: -yearModel.taxes - yearModel.costs,\n                date: yearModel.endDate,\n            });\n            lineData[dataToIndex.inflation].push({\n                value: -yearModel.inflation - yearModel.taxes - yearModel.costs,\n                date: yearModel.endDate,\n            });\n            let heightOffset = 0;\n            for (const etfIdentifier in visualizationModel.etfIdentifierToRatio) {\n                lineData[dataToIndex[etfIdentifier + capitalIdentifier]].push({\n                    value: yearModel.etfs[etfIdentifier].capital + heightOffset,\n                    date: yearModel.endDate,\n                });\n                lineData[dataToIndex[etfIdentifier + dividendIdentifier]].push({\n                    value: yearModel.etfs[etfIdentifier].capital - yearModel.etfs[etfIdentifier].dividend + heightOffset,\n                    date: yearModel.endDate,\n                });\n                heightOffset += yearModel.etfs[etfIdentifier].capital;\n            }\n        }\n\n        // Append miscellaneous data to array.\n        lineData[dataToIndex.inflation].cssClass = 'inflation';\n        lineData[dataToIndex.taxes].cssClass = 'taxes';\n        lineData[dataToIndex.costs].cssClass = 'costs';\n        for (const etfIdentifier in visualizationModel.etfIdentifierToRatio) {\n            lineData[dataToIndex[etfIdentifier + dividendIdentifier]].cssClass = `${etfIdentifier}_dividend`;\n            lineData[dataToIndex[etfIdentifier + capitalIdentifier]].cssClass = `${etfIdentifier}_total_amount`;\n        }\n\n        // create scales\n        const minVal = d3.min(lineData[dataToIndex.inflation].map(e => e.value));\n        const maxVal = d3.max(lineData[lineData.length - 1].map(e => e.value));\n\n        const yScale = d3.scaleLinear().domain([minVal, maxVal]).range([height, 0]);\n\n        const xScale = d3\n            .scaleTime()\n            .domain([visualizationModel.dates[0], visualizationModel.nextFutureDate])\n            .range([0, width]);\n\n        // Draw axis\n        svg.append('g')\n            .style('font-size', '20px')\n            .call(d3.axisLeft(yScale).tickFormat(d => `${d.toLocaleString()} EUR`));\n\n        svg.append('g')\n            .style('font-size', '20px')\n            .attr('transform', `translate(0, ${height})`)\n            .call(d3.axisBottom(xScale));\n\n        // Draw zero line.\n        svg.append('g')\n            .append('line')\n            .attr('x1', xScale(visualizationModel.dates[0]))\n            .attr('y1', yScale(0))\n            .attr('x2', xScale(visualizationModel.nextFutureDate))\n            .attr('y2', yScale(0))\n            .attr('stroke-width', zeroLineStrokeWidth)\n            .attr('stroke', 'black');\n\n        for (let i = 0; i < lineData.length; i++) {\n            svg.append('path')\n                .datum(lineData[i])\n                .attr('fill', 'none')\n                .attr('class', d => d.cssClass)\n                .attr('stroke-width', 3)\n                .attr(\n                    'd',\n                    d3\n                        .line()\n                        .x(d => xScale(d.date))\n                        .y(d => yScale(d.value))\n                );\n        }\n    }\n}\n\nexport default LineChart3D;\n","import React from 'react';\nimport ForecastModelSingleton from '../model/ForecastModel';\nimport VisualizationModel from '../model/VisualizationModel';\nimport LineChart3D from '../renderer/LineChartd3';\n\nconst STARTING_CAPITAL_IDENTIFIER = 'startingCapital';\nconst MONTHLY_INVESTMENT_IDENTIFIER = 'monthlyInvestment';\nconst TRANSACTION_COSTS_IDENTIFIER = 'transactionCosts';\nconst TRANSACTION_COSTS_TYPE_IDENTIFIER = 'transactionCostsType';\nconst SAVING_PHASE_IDENTIFIER = 'savingPhase';\nconst PAYOUT_PHASE_IDENTIFIER = 'payoutPhase';\nconst AGE_IDENTIFIER = 'age';\nconst TAX_FREE_AMOUNT_IDENTIFIER = 'taxFreeAmount';\n\nconst identifierToLabel = {\n    [STARTING_CAPITAL_IDENTIFIER]: 'Starting Capital',\n    [MONTHLY_INVESTMENT_IDENTIFIER]: 'Monthly Investment',\n    [TRANSACTION_COSTS_IDENTIFIER]: 'Transaction Costs',\n    [TRANSACTION_COSTS_TYPE_IDENTIFIER]: 'Fixes Amount ?',\n    [SAVING_PHASE_IDENTIFIER]: 'Saving Phase',\n    [PAYOUT_PHASE_IDENTIFIER]: 'Payout Phase',\n    [AGE_IDENTIFIER]: 'Your Age',\n    [TAX_FREE_AMOUNT_IDENTIFIER]: 'Tax Free Amount',\n};\n\nclass InputForm extends React.Component {\n    constructor(props) {\n        super(props);\n        this.state = {\n            [STARTING_CAPITAL_IDENTIFIER]: { value: 10000, type: 'text' },\n            [MONTHLY_INVESTMENT_IDENTIFIER]: { value: 100, type: 'text' },\n            [TRANSACTION_COSTS_IDENTIFIER]: { value: 0.005, type: 'text' },\n            [TRANSACTION_COSTS_TYPE_IDENTIFIER]: { value: false, type: 'checkbox' },\n            [SAVING_PHASE_IDENTIFIER]: { value: 40, type: 'text' },\n            [PAYOUT_PHASE_IDENTIFIER]: { value: 20, type: 'text' },\n            [AGE_IDENTIFIER]: { value: 30, type: 'text' },\n            [TAX_FREE_AMOUNT_IDENTIFIER]: { value: 801, type: 'text' },\n        };\n\n        this.ref = React.createRef();\n        this.handleChange = this.handleChange.bind(this);\n    }\n\n    handleChange(changedValue, changedStateIdentifier) {\n        this.setState({\n            [changedStateIdentifier]: { value: changedValue, type: this.state[changedStateIdentifier].type },\n        });\n        console.log(`State ${changedStateIdentifier} changed value to ${changedValue}.`);\n    }\n\n    getVisualizationModel(){\n        return new VisualizationModel(\n            this.state[STARTING_CAPITAL_IDENTIFIER].value,\n            this.state[MONTHLY_INVESTMENT_IDENTIFIER].value,\n            this.state[SAVING_PHASE_IDENTIFIER].value,\n            { IBM: 1.0 },\n            { percentageCosts: 0.0, fixedCosts: 5.0 },\n            this.state[AGE_IDENTIFIER].value,\n            this.state[TAX_FREE_AMOUNT_IDENTIFIER].value,\n        );\n    }\n\n    async componentDidMount() {\n        ForecastModelSingleton.configure('demo');\n        this.forecastModel = ForecastModelSingleton.getInstance();\n        await this.forecastModel.loadAndCacheHistoricalETFData('IBM');\n        \n        new LineChart3D().render(this.getVisualizationModel(), this.ref.current);\n    }\n\n    componentDidUpdate(){\n        new LineChart3D().render(this.getVisualizationModel(), this.ref.current);\n    }\n\n    render() {\n        return (\n            <React.Fragment>\n                <form>\n                    {Object.keys(this.state).map(stateIdentifier => (\n                        <InputFormElement\n                            key={stateIdentifier}\n                            label={identifierToLabel[stateIdentifier]}\n                            value={this.state[stateIdentifier].value}\n                            type={this.state[stateIdentifier].type}\n                            onValueChange={this.handleChange}\n                            stateIdentifier={stateIdentifier}\n                        />\n                    ))}\n                </form>\n                <div ref={this.ref}></div>\n            </React.Fragment>\n        );\n    }\n}\n\nclass InputFormElement extends React.Component {\n    constructor(props) {\n        super(props);\n        this.handleChange = this.handleChange.bind(this);\n    }\n\n    handleChange(e) {\n        let newValue = e.target.value;\n        if (this.props.type === 'checkbox') {\n            newValue = !this.props.value;\n        }\n        this.props.onValueChange(newValue, this.props.stateIdentifier);\n    }\n\n    render() {\n        return (\n            <label>\n                {this.props.label}\n                <input type={this.props.type} value={this.props.value} onChange={this.handleChange} />\n            </label>\n        );\n    }\n}\n\nexport default InputForm;\n","import './App.css';\nimport InputForm from './components/InputForm';\n\nfunction App() {\n    return (\n        <div className=\"Input\">\n            <InputForm />\n        </div>\n    );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}