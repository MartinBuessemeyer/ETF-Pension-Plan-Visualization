{"version":3,"sources":["helpers/utils.js","model/ForecastModel.js","model/InvestmentModel.js","renderer/LineChartd3.js","renderer/CashflowBarChartd3.js","components/Visualization.jsx","components/InputForm.jsx","App.js","reportWebVitals.js","index.js"],"names":["timeDiffIgnoreDivisor","numberOfMonthsOfAYear","isFirstMonthOfAYear","date","getMonth","loadHistoricalETFData","etfIdentifier","apiKey","a","d3","entry","Date","timestamp","toString","dividend","parseFloat","course","historicalData","sort","b","etfHistoricalToCourseForecastArray","map","dateToTimestamp","etfHistoricalToDividendForecastArray","currentYear","getFullYear","dividendForecastArray","forEach","length","push","Math","floor","getTime","HistoricalDataNotPresentException","this","message","name","ForecastModelSingleton","coursePredictors","dividendPredictors","courseForecastArray","maxTimestampBeforeCoursePredictorRepetition","_calculateMaxTimestampBeforePredictorRepetition","maxYearBeforeDividendPredictorRepetition","history","forecastArray","lastTimestampToIncludeInPrediction","abs","backCastTimeFactor","backCastTimestampConstant","filteredForecastArray","filter","regression","linear","order","precision","year","lastYearToIncludeInPrediction","_courseDateToPredictorTimestampAndDateTimestamp","predictorTimestamp","_createCoursePredictorIfNotPresent","predict","predictorYear","_dividendYearToPredictorYear","_createDividendPredictorIfNotPresent","max","backCastTimeConstant","backCastTimeDate","setMonth","instance","getInstance","firstTimestamp","lastTimestamp","corporateTaxRatio","getNextMonthDate","newDate","calculateDividend","isLastMonthOfAYear","predictDividend","calculateCosts","amount","costConfiguration","costs","percentageCosts","fixedCosts","amountWithoutCosts","subtractTaxFreeGain","taxAmount","taxFreeAmount","getTotalShareValue","investmentStep","totalShares","sharePrizes","getNewShareValue","newShares","calculateAndAddInflation","initialDate","endDate","sumTotalValues","sum","sumOfTotalValues","timeFactor","inflation","pow","addAccumulationMonth","investmentSteps","investment","etfToRatio","configOptions","forecast","prevInvestmentStep","newInvestmentStep","dividendNewShares","dividendTotalShares","totalCosts","totalInvestedMoney","newInvestedMoney","totalTaxes","totalPayout","newPayout","costConfig","investmentOfEtfWithoutCosts","etfSharePrize","predictCourse","dividendPayoutMoneyPerShare","newSharesByDividend","leftoverTaxFreeAmount","value","min","summedTaxes","decemberInvestmentStep","firstInvestmentStepOfThisYear","accumulatedBasicProfit","i","profitOverAllTime","profitOfPreviousYears","amountToApplyTaxes","calculateTaxes","newTaxes","newLeftoverTaxFreeAmount","addPayoutMonth","sellingAmount","leftoverAlreadyPaidTaxes","payoutStats","taxes","investmentStepsIdx","amountToSell","amountAlreadySold","costsToPay","alreadyPaidCosts","payoutInvestmentStepIdxForFIFO","currentSharesLeft","alreadySoldShares","leftoverAmountToSell","currentInvestmentStepForFIFO","currentValueOfShares","amountToSellWithCosts","amountOfSharesToSell","amountToSellWithoutCosts","initialValueOfShares","amountToPayTaxes","taxesToPay","payoutAmount","amountOfDividendSharesLeft","amountOfDividendSharesSold","generateEmptyInvestmentStep","emptyInvestmentStep","InvestmentModel","startCapital","monthlyInvestment","monthlyPayout","savingPhaseLength","age","expectationOfLife","_calculateTimestampsForModel","_calculateModel","lifeExpectation","fadeOutYears","yearsLeft","now","beginningDate","endSavingPhaseDate","setFullYear","calculateForecastInterval","startDate","savingDates","currentDate","payoutDates","slice","savingDate","payoutDate","LineChart3D","renderDivRef","etfLineColors","IBM","total","innerHTML","svg","append","attr","width","height","dataToIndex","currentIdx","capitalIdentifier","dividendIdentifier","lineData","heightOffset","totalShareValue","totalDividendShareValue","color","minVal","e","maxVal","yScale","domain","range","dateExtent","d","xScale","style","call","tickFormat","toLocaleString","datum","x","y","CashflowBarChart","rectData","sumNewInvestedMoney","sumNewPayout","yStart","yEnd","rectWidth","barArray","selectAll","data","enter","loadHistoricData","configure","loadAndCacheHistoricalETFData","console","log","Visualization","props","firstSVGRef","React","createRef","secondSVGRef","STARTING_CAPITAL_IDENTIFIER","MONTHLY_INVESTMENT_IDENTIFIER","MONTHLY_PAYOUT_IDENTIFIER","SAVING_PHASE_IDENTIFIER","TAX_FREE_AMOUNT_IDENTIFIER","state","TRANSACTION_COSTS_TYPE_IDENTIFIER","TRANSACTION_COSTS_IDENTIFIER","AGE_IDENTIFIER","LIFE_EXPECTATION","investmentModel","getInvestmentModel","render","current","drawVisualization","Fragment","ref","Component","identifierToLabel","transformInputToInt","caller","intVal","parseInt","target","isNaN","transformInputToFloat","transformCheckboxInput","InputForm","type","transformFunction","handleChange","bind","changedValue","changedStateIdentifier","currentValues","setState","visualizationProps","identifier","constructVisualizationProps","Object","keys","stateIdentifier","label","onValueChange","InputFormElement","onChange","App","className","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","StrictMode","document","getElementById"],"mappings":"gSAGMA,EAAwB,MAIjBC,EAAwB,GAW9B,SAASC,EAAoBC,GAChC,OAA2B,IAApBA,EAAKC,WAGT,SAAeC,EAAtB,oC,4CAAO,WAAqCC,EAAeC,GAApD,eAAAC,EAAA,sEAC0BC,IAAA,yFACyDH,EADzD,mBACiFC,EADjF,kBAEzB,SAAAG,GACI,MAAO,CACHP,KAAM,IAAIQ,KAAKD,EAAME,UAAUC,YAC/BC,SAAUC,WAAWL,EAAM,oBAC3BM,OAAQD,WAAWL,EAAM,uBAPlC,cACGO,EADH,QAWYC,MAAK,SAACV,EAAGW,GAAJ,OAAUX,EAAEL,KAAOgB,EAAEhB,QAXtC,kBAYIc,GAZJ,4C,sBAeA,SAASG,EAAmCH,GAC/C,OAAOA,EAAeI,KAAI,SAAAX,GAAK,MAAI,CAACY,EAAgBZ,EAAMP,MAAOO,EAAMM,WAIpE,SAASO,EAAqCN,GACjD,IAAIO,EAAcP,EAAe,GAAGd,KAAKsB,cACnCC,EAAwB,CAAC,CAACF,EAAa,IAU7C,OATAP,EAAeU,SAAQ,SAAAjB,GACfA,EAAMP,KAAKsB,gBAAkBD,EAC7BE,EAAsBA,EAAsBE,OAAS,GAzCvB,IAyCyDlB,EAAMI,UAE7FU,EAAcd,EAAMP,KAAKsB,cACzBC,EAAsBG,KAAK,CAACL,EAAad,EAAMI,eAGvDY,EAAsBR,MAAK,SAACV,EAAGW,GAAJ,OAAUX,EAhDI,GAgD+BW,EAhD/B,MAiDlCO,EAGJ,SAASJ,EAAgBnB,GAC5B,OAAO2B,KAAKC,MAAM5B,EAAK6B,UAAYhC,GAOhC,SAASiC,EAAkC3B,GAC9C4B,KAAKC,QAAL,yEAAiF7B,GACjF4B,KAAKE,KAAO,oCCtDT,IAAMC,EAAb,WAOI,aAAe,oBACXH,KAAKjB,eAAiB,GACtBiB,KAAKI,iBAAmB,GACxBJ,KAAKK,mBAAqB,GAVlC,wGAsDI,WAAoCjC,GAApC,uBAAAE,EAAA,2DACQF,KAAiB4B,KAAKjB,gBAD9B,iEAIiCZ,EAAsBC,GAJvD,OAIUW,EAJV,OAMUuB,EAAsBpB,EAAmCH,GACzDwB,EAA8CJ,EAAuBK,gDACvEF,GAGEd,EAAwBH,EAAqCN,GAC7D0B,EAA2CN,EAAuBK,gDACpEhB,GAGJQ,KAAKjB,eAAeX,GAAiB,CACjCsC,QAAS3B,EACTuB,oBAAqBA,EACrBd,sBAAuBA,GAE3BQ,KAAKI,iBAAiBhC,GAAiB,CACnCmC,4CAA6CA,GAEjDP,KAAKK,mBAAmBjC,GAAiB,CACrCqC,yCAA0CA,GAzBlD,iDAtDJ,uGAmFI,SAAmCrC,EAAeM,GAE9C,KAAIA,KAAasB,KAAKI,iBAAiBhC,IAAvC,CAGA,IAAMuC,EAAgBX,KAAKjB,eAAeX,GAAekC,oBACnDM,EACFD,EAAcA,EAAcjB,OAAS,GDlGJ,GCmGjCE,KAAKiB,IAAIF,EAAcA,EAAcjB,OAAS,GDnGb,GCmGiDhB,GAC9EyB,EAAuBW,mBAC3BX,EAAuBY,0BACrBC,EAAwBL,EAAcM,QACxC,SAAAzC,GAAK,OAAIA,EDvGwB,ICuGgBoC,KAErDZ,KAAKI,iBAAiBhC,GAAeM,GAAawC,IAAWC,OAAOH,EAAuB,CACvFI,MAAO,EACPC,UAAW,QAnGvB,6DAuGI,SAAgDpD,EAAMG,GAClD,IAAMM,EAAYU,EAAgBnB,GAClC,MAAO,CACHS,EAAYsB,KAAKI,iBAAiBhC,GAAemC,4CAC3CP,KAAKI,iBAAiBhC,GAAemC,4CACrC7B,EACNA,KA7GZ,kDAiHI,SAAqCN,EAAekD,GAEhD,KAAIA,KAAQtB,KAAKK,mBAAmBjC,IAApC,CAGA,IAAMuC,EAAgBX,KAAKjB,eAAeX,GAAeoB,sBACnD+B,EACFZ,EAAcA,EAAcjB,OAAS,GDhIJ,GCiIjCE,KAAKiB,IAAIF,EAAcA,EAAcjB,OAAS,GDjIb,GCiIiD4B,GAC9EnB,EAAuBW,mBAC3BX,EAAuBY,0BACrBC,EAAwBL,EAAcM,QACxC,SAAAzC,GAAK,OAAIA,EDrIwB,ICqIgB+C,KAErDvB,KAAKK,mBAAmBjC,GAAekD,GAAQJ,IAAWC,OAAOH,EAAuB,CACpFI,MAAO,EACPC,UAAW,QAjIvB,0CAqII,SAA6BjD,EAAekD,GACxC,OAAOtB,KAAKK,mBAAmBjC,GAAeqC,yCAA2Ca,EACnFtB,KAAKK,mBAAmBjC,GAAeqC,yCACvCa,IAxId,2BA2II,SAAclD,EAAeH,GACzB,KAAMG,KAAiB4B,KAAKI,kBACxB,MAAM,IAAIL,EAAkC3B,GAFjB,MAIS4B,KAAKwB,gDACzCvD,EACAG,GAN2B,mBAIxBqD,EAJwB,KAIJ/C,EAJI,KAS/B,OADAsB,KAAK0B,mCAAmCtD,EAAeqD,GAChDzB,KAAKI,iBAAiBhC,GAAeqD,GAAoBE,QAAQjD,GD3JtC,KCO1C,6BAuJI,SAAgBN,EAAekD,GAC3B,KAAMlD,KAAiB4B,KAAKK,oBACxB,MAAM,IAAIN,EAAkC3B,GAEhD,IAAMwD,EAAgB5B,KAAK6B,6BAA6BzD,EAAekD,GAEvE,OADAtB,KAAK8B,qCAAqC1D,EAAewD,GAClDhC,KAAKmC,IACR,EACA/B,KAAKK,mBAAmBjC,GAAewD,GAAeD,QAAQL,GDtKhC,OCO1C,wBAaI,SAAiBjD,GAA2D,IAAnDyC,EAAkD,uDAA7B,EAAGkB,EAA0B,uDAAH,EACpE7B,EAAuB9B,OAASA,EAChC8B,EAAuBW,mBAAqBA,EAE5C,IAAMmB,EAAmB,IAAIxD,KAAK,GAKlC,GAJAwD,EAAiBC,SAASF,GAC1B7B,EAAuBY,0BAA4B3B,EAAgB6C,GAG5B,MAAnC9B,EAAuBgC,SAAkB,CACzC,IAAMA,EAAWhC,EAAuBiC,cACxC,IAAK,IAAMhE,KAAiB+D,EAAS/B,iBACjC+B,EAAS/B,iBAAiBhC,GAAiB,CACvCmC,4CAA6CJ,EAAuBK,gDAChE2B,EAASpD,eAAeX,GAAekC,sBAInD,IAAK,IAAMlC,KAAiB+D,EAAS9B,mBACjC8B,EAAS9B,mBAAmBjC,GAAiB,CACzCqC,yCAA0CN,EAAuBK,gDAC7D2B,EAASpD,eAAeX,GAAeoB,2BAlC/D,yBAyCI,WAII,OAHuC,MAAnCW,EAAuBgC,WACvBhC,EAAuBgC,SAAW,IAAIhC,GAEnCA,EAAuBgC,WA7CtC,6DAgDI,SAAuDxB,GACnD,IAAM0B,EAAiB1B,EAAc,GDzDA,GC0D/B2B,EAAgB3B,EAAcA,EAAcjB,OAAS,GD1DtB,GC2DrC,OAAO4C,GAAiBA,EAAgBD,GAAkBlC,EAAuBW,uBAnDzF,KAAaX,EACFgC,SAAW,KADThC,EAEF9B,OAAS,KAFP8B,EAGF6B,qBAAuB,KAHrB7B,EAIFW,mBAAqB,KAgKjBX,Q,OC5KToC,EAAoB,OAG1B,SAASC,EAAiBvE,GACtB,IAAMwE,EAAU,IAAIhE,KAAKR,GAEzB,OADAwE,EAAQP,SAASjE,EAAKC,WAAa,GAC5BuE,EAGX,SAASC,EAAkBtE,EAAeH,GACtC,OFLG,SAA4BA,GAC/B,OAA2BF,KAApBE,EAAKC,WEIPyE,CAAmB1E,GAGbkC,EAAuBiC,cAAcQ,gBAAgBxE,EAAeH,EAAKsB,eAFzE,EAMf,SAASsD,EAAeC,EAAQC,GAC5B,IAAIC,EAAQF,EAASC,EAAkBE,gBAAkBF,EAAkBG,WACrEC,EAAqBvD,KAAKmC,IAAIe,EAASE,EAAO,GAEpD,MAAO,CAACG,EADRH,EAAQF,EAASK,GAIrB,SAASC,EAAoBC,EAAWC,GAGpC,MAAO,CAFe1D,KAAKmC,IAAI,EAAGsB,EAAYC,GAChB1D,KAAKmC,IAAI,EAAGuB,EAAgBD,IAIvD,SAASE,EAAmBnF,EAAeoF,GAC9C,OAAOA,EAAeC,YAAYrF,GAAiBoF,EAAeE,YAAYtF,GAGlF,SAASuF,EAAiBvF,EAAeoF,GACrC,OAAOA,EAAeI,UAAUxF,GAAiBoF,EAAeE,YAAYtF,GAWhF,SAASyF,EAAyBL,EAAgBM,EAAaC,GAE3D,IAAMC,EAVV,SAA0BR,GACtB,IAAIS,EAAM,EACV,IAAK,IAAM7F,KAAiBoF,EAAeC,YACvCQ,GAAOV,EAAmBnF,EAAeoF,GAE7C,OAAOS,EAKgBC,CAAiBV,GAClCW,EACFJ,EAAQxE,cACRuE,EAAYvE,eACXwE,EAAQ7F,WAAa4F,EAAY5F,YAAcH,EACpDyF,EAAeY,UAAYJ,EAAiBA,EAAiBpE,KAAKyE,IAAI,IAAmBF,GA+DtF,SAASG,EAAqBC,EAAiBC,EAAYvG,EAAM6F,EAAaW,EAAYC,GAC7F,IAAMC,EAAWxE,EAAuBiC,cACpCY,EAAQ,EACN4B,EAAqBL,EAAgBA,EAAgB7E,OAAS,GAC9DmF,EAAoB,CACtB5G,KAAMA,EACN2F,UAAW,GACXH,YAAY,eAAMmB,EAAmBnB,aACrCqB,kBAAmB,GACnBC,oBAAoB,eAAMH,EAAmBG,qBAC7CC,WAAYJ,EAAmBI,WAC/BtB,YAAa,GACbuB,mBAAmB,eAAML,EAAmBK,oBAC5CC,iBAAkB,GAClBC,WAAYP,EAAmBO,WAC/BC,YAAY,eAAMR,EAAmBQ,aACrCC,UAAW,IAEf,IAAK,IAAMjH,KAAiBqG,EAAY,CACpC,IADoC,EAEY5B,EADf4B,EAAWrG,GAAiBoG,EAGzDE,EAAcY,YAJkB,mBAE7BC,EAF6B,KAMpCvC,GANoC,KAOpC6B,EAAkBK,iBAAiB9G,GAAiBmH,EACpDV,EAAkBI,mBAAmB7G,IAAkBmH,EAEvD,IAAMC,EAAgBb,EAASc,cAAcrH,EAAeH,GACtD2F,EAAY2B,EAA8BC,EAChDX,EAAkBnB,YAAYtF,GAAiBoH,EAC/CX,EAAkBjB,UAAUxF,GAAiBwF,EAE7C,IAAM8B,EAA8BhD,EAAkBtE,EAAeH,GAE/D0H,EADsBd,EAAkBpB,YAAYrF,GAAiBsH,EACzBF,EAClDX,EAAkBjB,UAAUxF,IAAkBuH,EAC9Cd,EAAkBC,kBAAkB1G,GAAiBuH,EACrDd,EAAkBE,oBAAoB3G,IAAkBuH,EAExDd,EAAkBpB,YAAYrF,IAAkByG,EAAkBjB,UAAUxF,GAC5EyG,EAAkBQ,UAAUjH,GAAiB,EAEjDyG,EAAkBG,YAAchC,EA3C4E,MAhDhH,SAAwBuB,EAAiBtG,EAAM2H,EAAuBnB,GAClE,IAAKzG,EAAoBC,IAASsG,EAAgB7E,OAAS,EACvD,MAAO,CAAC,EAAGkG,GAEf,IF/DkBC,EAAOC,EAAK/D,EE+D1BgE,EAAc,EACZC,EAAyBzB,EAAgBA,EAAgB7E,OAAS,GAGlEuG,EACF1B,EAAgB7E,OAAS3B,EAAwB,EAC3CwG,EAAgBA,EAAgB7E,OAAS3B,GACzCwG,EAAgB,GAC1B,IAAK,IAAMnG,KAAiBqG,EAAY,CAGpC,IAFA,IAAIyB,EAAyB,EAEpBC,EAAI,EAAGA,EAAIpI,GAAyBwG,EAAgB7E,OAASyG,EAAI,EAAGA,IAEzED,GACKvC,EAAiBvF,EAFQmG,EAAgBA,EAAgB7E,OAASyG,IAETA,EAAKpI,EAGvEmI,GACK3C,EAAmBnF,EAAe6H,IAC9BlI,EAAwBkI,EAA8BhI,KAAKC,YAChEH,EACJmI,GAA0B,MAC1B,IAEME,EAFqB7C,EAAmBnF,EAAe4H,GAEdA,EAAuBf,mBAAmB7G,GACrFiI,EAAwB,EACxB9B,EAAgB7E,OAAS3B,IACzBsI,EAAwBzG,KAAKmC,IACzB,EACAwB,EAAmBnF,EAAemG,EAAgBA,EAAgB7E,OAAS,EAAI3B,IAC3EwG,EAAgBA,EAAgB7E,OAAS,EAAI3B,GAAuBkH,mBAChE7G,KAKhB,IACIkI,GFpGUT,EEmGWO,EAAoBC,EFnGxBP,EEoG4B,EFpGvB/D,EEoG0BmE,EFnGjDtG,KAAKmC,IAAI+D,EAAKlG,KAAKkG,IAAID,EAAO9D,KEsEG,EA8BUqB,EAAoBkD,EAAoBV,GA9BlD,mBA8BnCU,EA9BmC,KA8BfV,EA9Be,KA+BpCG,GAhHiB,GAgHFO,EAAwC/D,EAE3D,MAAO,CAACwD,EAAaH,GA+CwBW,CACzChC,EACAtG,EACAyG,EAAcpB,cACdmB,GAhDwG,mBA4CrG+B,EA5CqG,KA4C3FC,EA5C2F,KAsD5G,OAJA5B,EAAkBM,YAAcqB,EAChC3C,EAAyBgB,EAAmBf,EAAa7F,GACzDsG,EAAgB5E,KAAKkF,GAEd4B,EAGX,SAASC,EACLnC,EACAoC,EACAlC,EACAxG,EACA6F,EACAY,EACAkC,EACAhB,EACAiB,GAEI7I,EAAoBC,KACpB2H,EAAwBlB,EAAcpB,eAE1C,IAAMqB,EAAWxE,EAAuBiC,cACpCY,EAAQ,EACR8D,EAAQ,EACNlC,EAAqBL,EAAgBA,EAAgB7E,OAAS,GAC9DmF,EAAoB,CACtB5G,KAAMA,EACN2F,UAAW,GACXH,YAAY,eAAMmB,EAAmBnB,aACrCqB,kBAAmB,GACnBC,oBAAoB,eAAMH,EAAmBG,qBAC7CC,WAAYJ,EAAmBI,WAC/BtB,YAAa,GACbuB,mBAAmB,eAAML,EAAmBK,oBAC5CC,iBAAkB,GAClBC,WAAYP,EAAmBO,WAC/BC,YAAY,eAAMR,EAAmBQ,aACrCC,UAAW,IAEf,IAAK,IAAMjH,KAAiBqG,EAAY,CACpC,IAAMe,EAAgBb,EAASc,cAAcrH,EAAeH,GAK5D,GAJA4G,EAAkBnB,YAAYtF,GAAiBoH,EAC/CX,EAAkBQ,UAAUjH,GAAiB,EAC7CyG,EAAkBK,iBAAiB9G,GAAiB,EAEhDyI,EAAYzI,GAAe2I,mBAAqBxC,EAAgB7E,OAAQ,CAUxE,IARA,IAAMsH,EAAeL,EAAgBlC,EAAWrG,GAC5C6I,EAAoB,EAClBC,EAAarE,EAAemE,EAActC,EAAcY,YAAY,GACtE6B,EAAmB,EACnBC,EAAiCP,EAAYzI,GAAe2I,mBAC5DM,EACA9C,EAAgB6C,GAAgCxD,UAAUxF,GAC1DyI,EAAYzI,GAAekJ,kBACxBF,EAAiC7C,EAAgB7E,OAAQ0H,IAAkC,CAC9F,IAAMG,EAAuBP,EAAeC,EACtCO,EAA+BjD,EAAgB6C,GAE/CK,EACFjC,GACC4B,IAAmCP,EAAYzI,GAAe2I,mBACzDS,EAA6B5D,UAAUxF,GACvCyI,EAAYzI,GAAekJ,kBAC3BE,EAA6B5D,UAAUxF,IAC3CsJ,EAAwB9H,KAAKkG,IAAI2B,EAAsBF,GACvDI,EAAuBD,EAAwBlC,EACrD6B,EAAoBG,EAA6B5D,UAAUxF,GAAiBuJ,EAC5EN,GACID,IAAmCP,EAAYzI,GAAe2I,mBACxDF,EAAYzI,GAAekJ,kBAC3B,EAEV,IAAMM,EAA2BhI,KAAKmC,IAAI,EAAG2F,GAAyBR,EAAaC,IACnFA,GAAoBvH,KAAKmC,IAAI,EAAG2F,EAAwBE,GAExD,IAAMC,EACFF,EAAuBH,EAA6B9D,YAAYtF,GAChE0J,EAAmBlI,KAAKmC,IAAI,EAAG6F,EAA2BC,GAvBgC,EAyBlDzE,EACxC0E,EACAlC,GA3B0F,mBAyB7FkC,EAzB6F,KAyB3ElC,EAzB2E,KA6B9F,IAAImC,EA3PK,GA2PQD,EAAsCvF,EA7BuC,EA8BrDa,EAAoB2E,EAAYnB,GA9BqB,mBA8B7FmB,EA9B6F,KA8BjFnB,EA9BiF,KA+B9FE,GAASiB,EACT,IAAMC,EAAeJ,EAA2BG,EAEhDlD,EAAkBQ,UAAUjH,IAAkB4J,EAC9CnD,EAAkBO,YAAYhH,IAAkB4J,EAEhDnD,EAAkBpB,YAAYrF,IAAkBuJ,EAChDV,GAAqBS,EAGrB,IAAIO,EAA6B,EAE7BA,EADAb,IAAmCP,EAAYzI,GAAe2I,mBACjCnH,KAAKmC,IAC9B,EACAyF,EAA6B1C,kBAAkB1G,GAC3CyI,EAAYzI,GAAekJ,mBAGNE,EAA6B1C,kBAAkB1G,GAEhF,IAAM8J,EAA6BtI,KAAKkG,IAAImC,EAA4BN,GAIxE,GAHA9C,EAAkBE,oBAAoB3G,IAAkB8J,EAGpDjB,GAAqBD,EACrB,MAGRhE,GAASmE,EAETN,EAAYzI,GAAe2I,mBAAqBK,EAChDP,EAAYzI,GAAe2I,oBAA4C,IAAtBM,EAA0B,EAAI,EAE/ER,EAAYzI,GAAekJ,kBACvBF,EAAiC7C,EAAgB7E,OAC3C6E,EAAgB6C,GAAgCxD,UAAUxF,GAAiBiJ,EAC3E,EAId,IAEM1B,EADFd,EAAkBpB,YAAYrF,GAAiBsE,EAAkBtE,EAAeH,GAClCuH,EAClDX,EAAkBjB,UAAUxF,GAAiBuH,EAC7Cd,EAAkBpB,YAAYrF,IAAkBuH,EAChDd,EAAkBC,kBAAkB1G,GAAiBuH,EACrDd,EAAkBE,oBAAoB3G,IAAkBuH,EAO5D,OAJAd,EAAkBG,YAAchC,EAChC6B,EAAkBM,YAAc2B,EAChCjD,EAAyBgB,EAAmBf,EAAa7F,GACzDsG,EAAgB5E,KAAKkF,GACd,CAAC+B,EAA0BhB,GAGtC,SAASuC,EAA4B1D,EAAYxG,GAC7C,IAAM0G,EAAWxE,EAAuBiC,cAClCgG,EAAsB,CACxBnK,KAAMA,EACN+G,WAAY,EACZG,WAAY,EACZvB,UAAW,GACXH,YAAa,GACbqB,kBAAmB,GACnBC,oBAAqB,GACrBE,mBAAoB,GACpBG,YAAa,GACbC,UAAW,GACX3B,YAAa,IAEjB,IAAK,IAAMtF,KAAiBqG,EACxB2D,EAAoBxE,UAAUxF,GAAiB,EAC/CgK,EAAoB3E,YAAYrF,GAAiB,EACjDgK,EAAoBtD,kBAAkB1G,GAAiB,EACvDgK,EAAoBrD,oBAAoB3G,GAAiB,EACzDgK,EAAoBnD,mBAAmB7G,GAAiB,EACxDgK,EAAoBhD,YAAYhH,GAAiB,EACjDgK,EAAoB/C,UAAUjH,GAAiB,EAC/CgK,EAAoB1E,YAAYtF,GAAiBuG,EAASc,cAAcrH,EAAeH,GAE3F,OAAOmK,EAGJ,IAAMC,EAAb,WACI,WACIC,EACAC,EACAC,EACAC,EACAhE,EACAC,EACAgE,EACAC,GACD,oBACC3I,KAAKsI,aAAeA,EACpBtI,KAAKuI,kBAAoBA,EACzBvI,KAAKwI,cAAgBA,EACrBxI,KAAKyI,kBAAoBA,EACzBzI,KAAKyE,WAAaA,EAClBzE,KAAK0E,cAAgBA,EACrB1E,KAAK2I,kBAAoBA,EACzB3I,KAAK0I,IAAMA,EACX1I,KAAK4I,+BACL5I,KAAK6I,kBApBb,gEAuBI,WAOI,IAP4B,IAAD,EA/SnC,SAAmCH,EAAKI,EAAiBL,GAAuC,IAApBM,EAAmB,uDAAJ,GACjFC,EAAYF,EAAkBJ,EAC9BO,EAAM,IAAIxK,KACVyK,EAAgB,IAAIzK,KAAKwK,EAAI1J,cAAe0J,EAAI/K,WAAa,GAE7DiL,EAAqB,IAAI1K,KAAKyK,GACpCC,EAAmBC,YAAYF,EAAc3J,cAAgBkJ,GAC7D,IAAM1E,EAAU,IAAItF,KAAKyK,GAEzB,OADAnF,EAAQqF,YAAYF,EAAc3J,cAAgByJ,EAAYD,GACvD,CAACG,EAAeC,EAAoBpF,GAuSUsF,CAC7CrJ,KAAK0I,IACL1I,KAAK2I,kBACL3I,KAAKyI,mBAJkB,mBACpBa,EADoB,KACTH,EADS,KACWpF,EADX,KAMrBwF,EAAc,GAEZC,EAAcF,EAClBE,EAAcL,EACdK,EAAchH,EAAiBgH,GAE/BD,EAAY5J,KAAK6J,GAErBxJ,KAAKuJ,YAAcA,EAEnB,IADA,IAAME,EAAc,GACXD,EAAcL,EAAoBK,EAAczF,EAASyF,EAAchH,EAAiBgH,GAC7FC,EAAY9J,KAAK6J,GAErBxJ,KAAKyJ,YAAcA,EACnBzJ,KAAK8D,YAAcwF,IA3C3B,6BA8CI,WACI,IADc,EACV/E,EAAkB,CAAC4D,EAA4BnI,KAAKyE,WAAYzE,KAAKuJ,YAAY,KACjF3D,EAAwBtB,EACxBC,EACAvE,KAAKuI,kBAAoBvI,KAAKsI,aAC9BtI,KAAKuJ,YAAY,GACjBvJ,KAAK8D,YACL9D,KAAKyE,WACLzE,KAAK0E,eARK,cAUW1E,KAAKuJ,YAAYG,MAAM,IAVlC,IAUd,2BAAoD,CAAC,IAA1CC,EAAyC,QAChD/D,EAAwBtB,EACpBC,EACAvE,KAAKuI,kBACLoB,EACA3J,KAAK8D,YACL9D,KAAKyE,WACLzE,KAAK0E,gBAjBC,8BAuBd,IAAIkC,GAFJrC,EAAkBA,EAAgBmF,MAAM,IAEOnF,EAAgB7E,OAAS,GAAGyF,WACrE0B,EAAc,GACpB,IAAK,IAAMzI,KAAiB4B,KAAKyE,WAC7BoC,EAAYzI,GAAiB,CAAE2I,mBAAoB,EAAGO,kBAAmB,GA1B/D,oBA4BWtH,KAAKyJ,aA5BhB,IA4Bd,2BAA2C,CAAC,IAAjCG,EAAgC,UACalD,EAChDnC,EACAvE,KAAKwI,cACLxI,KAAKyE,WACLmF,EACA5J,KAAK8D,YACL9D,KAAK0E,cACLkC,EACAhB,EACAiB,GAVmC,mBACtCD,EADsC,KACZhB,EADY,MA5B7B,8BAyCd5F,KAAKuE,gBAAkBA,MAvF/B,KCpNesF,EA9Hf,sFACI,SAAOtF,EAAiBuF,GACpB,IAOMC,EAAgB,CAAEC,IAAK,CAAEC,MAAO,UAAWrL,SAAU,YAK3DkL,EAAaI,UAAY,GAEzB,IAAMC,EAAM5L,IACAuL,GACPM,OAAO,OACPC,KAAK,KAjBI,YAkBTA,KAAK,SAAU,QACfA,KAAK,QAAS,QACdA,KAAK,UANE,cAMgBC,KANhB,YAMuCC,MAC9CH,OAAO,KACPC,KAAK,YARE,oBAQwB,CApBpB,IACF,IAWF,MAWNG,EAAc,CAChBxH,MAAO,EACP8D,MAAO,EACP1C,UAAW,GAEXqG,EAAa,EACXC,EAAoB,UACpBC,EAAqB,WAC3B,IAAK,IAAMvM,KAAiBmG,EAAgB,GAAGd,YAC3C+G,EAAYpM,EAAgBuM,GAAsBF,IAClDD,EAAYpM,EAAgBsM,GAAqBD,IAIrD,IADA,IAAMG,EAAW,GACRzE,EAAI,EAAGA,EAAIsE,EAAYtE,IAC5ByE,EAASjL,KAAK,IAzCgB,oBA2CL4E,GA3CK,IA2ClC,2BAA8C,CAAC,IAApCf,EAAmC,QAC1CoH,EAASJ,EAAYxH,OAAOrD,KAAK,CAAEkG,OAAQrC,EAAewB,WAAY/G,KAAMuF,EAAevF,OAC3F2M,EAASJ,EAAY1D,OAAOnH,KAAK,CAC7BkG,OAAQrC,EAAewB,WAAaxB,EAAe2B,WACnDlH,KAAMuF,EAAevF,OAEzB2M,EAASJ,EAAYpG,WAAWzE,KAAK,CACjCkG,OAAQrC,EAAewB,WAAaxB,EAAe2B,WAAa3B,EAAeY,UAC/EnG,KAAMuF,EAAevF,OAEzB,IAAI4M,EAAe,EACnB,IAAK,IAAMzM,KAAiBoF,EAAeC,YAAa,CACpD,IAAMqH,EAAkBvH,EAAmBnF,EAAeoF,GACpDuH,EACFvH,EAAeuB,oBAAoB3G,GAAiBoF,EAAeE,YAAYtF,GACnFwM,EAASJ,EAAYpM,EAAgBsM,IAAoB/K,KAAK,CAC1DkG,MAAOiF,EAAkBD,EACzB5M,KAAMuF,EAAevF,OAEzB2M,EAASJ,EAAYpM,EAAgBuM,IAAqBhL,KAAK,CAC3DkG,MAAOiF,EAAkBC,EAA0BF,EACnD5M,KAAMuF,EAAevF,OAEzB4M,GAAgBC,IAlEU,8BA0ElC,IAAK,IAAM1M,KAHXwM,EAASJ,EAAYpG,WAAW4G,MAAQ,UACxCJ,EAASJ,EAAY1D,OAAOkE,MAAQ,UACpCJ,EAASJ,EAAYxH,OAAOgI,MAAQ,UACRzG,EAAgB,GAAGd,YAC3CmH,EAASJ,EAAYpM,EAAgBuM,IAAqBK,MAAQjB,EAAc3L,GAAeQ,SAC/FgM,EAASJ,EAAYpM,EAAgBsM,IAAoBM,MAAQjB,EAAc3L,GAAe6L,MAIlG,IAAMgB,EAAS1M,IAAOqM,EAASJ,EAAYpG,WAAWjF,KAAI,SAAA+L,GAAC,OAAIA,EAAErF,UAC3DsF,EAAS5M,IAAOqM,EAASA,EAASlL,OAAS,GAAGP,KAAI,SAAA+L,GAAC,OAAIA,EAAErF,UAEzDuF,EAAS7M,MAAiB8M,OAAO,CAACJ,EAAQE,IAASG,MAAM,CA7ElD,IA6E2D,IAClEC,EAAahN,IAAUqM,EAAS,IAAI,SAAAY,GAAC,OAAIA,EAAEvN,QAC3CwN,EAASlN,MAAe8M,OAAOE,GAAYD,MAAM,CAAC,EAhF5C,MAmFZnB,EAAIC,OAAO,KACNsB,MAAM,YAAa,QACnBC,KAAKpN,IAAY6M,GAAQQ,YAAW,SAAAJ,GAAC,gBAAOA,EAAEK,iBAAT,YAE1C1B,EAAIC,OAAO,KACNsB,MAAM,YAAa,QACnBrB,KAAK,YAFV,uBAtFa,IAsFb,MAGKsB,KAAKpN,IAAckN,IAGxBtB,EAAIC,OAAO,KACNA,OAAO,QACPC,KAAK,KAAMoB,EAAOF,EAAW,KAC7BlB,KAAK,KAAMe,EAAO,IAClBf,KAAK,KAAMoB,EAAOF,EAAW,KAC7BlB,KAAK,KAAMe,EAAO,IAClBM,MAAM,eA9Fa,GA+FnBA,MAAM,SAAU,SAErB,IAAK,IAAIvF,EAAI,EAAGA,EAAIyE,EAASlL,OAAQyG,IACjCgE,EAAIC,OAAO,QACN0B,MAAMlB,EAASzE,IACfuF,MAAM,UAAU,SAAAF,GAAC,OAAIA,EAAER,SACvBU,MAAM,eArGS,GAsGfA,MAAM,UAvGK,IAwGXA,MAAM,OAAQ,QACdrB,KACG,IACA9L,MAEKwN,GAAE,SAAAP,GAAC,OAAIC,EAAOD,EAAEvN,SAChB+N,GAAE,SAAAR,GAAC,OAAIJ,EAAOI,EAAE3F,eAxHzC,KC+FeoG,EAhGf,sFACI,SAAO1H,EAAiBuF,GACpB,IAIIQ,EAAQ,IAOZR,EAAaI,UAAY,GAEzB,IAdkC,EAc5BC,EAAM5L,IACAuL,GACPM,OAAO,OACPC,KAAK,KAhBI,aAiBTA,KAAK,SAAU,QACfA,KAAK,QAAS,QACdA,KAAK,UANE,cAMgBC,KANhB,YAMuCC,MAC9CH,OAAO,KACPC,KAAK,YARE,oBAQwB,CAnBpB,IACF,IAUF,MAWNG,EACQ,EADRA,EAEM,EAGN0B,EAAW,CAAC,GAAI,IA9BY,cA+BL3H,GA/BK,IA+BlC,2BAA8C,CAAC,IAApCf,EAAmC,QACtC2I,EAAsB,EACtBC,EAAe,EACnB,IAAK,IAAMhO,KAAiBoF,EAAe0B,iBACvCiH,GAAuB3I,EAAe0B,iBAAiB9G,GACvDgO,GAAgB5I,EAAe6B,UAAUjH,GAE7C8N,EAAS1B,GAAsB7K,KAAK,CAChC0M,OAAQ,EACRC,MAAOH,EACPlO,KAAMuF,EAAevF,KACrB+M,MAAO,YAEXkB,EAAS1B,GAAoB7K,KAAK,CAC9B0M,OAAQD,EACRE,KAAM,EACNrO,KAAMuF,EAAevF,KACrB+M,MAAO,aAhDmB,8BAqDlC,IAAMC,EAAS1M,IAAO2N,EAAS1B,GAAsBrL,KAAI,SAAA+L,GAAC,OAAIA,EAAEoB,SAC1DnB,EAAS5M,IAAO2N,EAAS1B,GAAoBrL,KAAI,SAAA+L,GAAC,OAAIA,EAAEmB,WAExDjB,EAAS7M,MAAiB8M,OAAO,CAACJ,EAAQE,IAASG,MAAM,CAlDlD,IAkD2D,IAClEC,EAAahN,IAAU2N,EAAS1B,IAAuB,SAAAgB,GAAC,OAAIA,EAAEvN,QAC9DwN,EAASlN,MAAe8M,OAAOE,GAAYD,MAAM,CAAC,EAAGhB,IACrDiC,EAAajC,EAAQ4B,EAAS1B,GAAsB9K,OApD7B,GAuD7ByK,EAAIC,OAAO,KACNsB,MAAM,YAAa,QACnBC,KAAKpN,IAAY6M,GAAQQ,YAAW,SAAAJ,GAAC,gBAAOA,EAAEK,iBAAT,YAE1C1B,EAAIC,OAAO,KACNsB,MAAM,YAAa,QACnBrB,KAAK,YAFV,uBA5Da,IA4Db,MAGKsB,KAAKpN,IAAckN,IAGxBtB,EAAIC,OAAO,KACNA,OAAO,QACPC,KAAK,KAAMoB,EAAOF,EAAW,KAC7BlB,KAAK,KAAMe,EAAO,IAClBf,KAAK,KAAMoB,EAAOF,EAAW,KAC7BlB,KAAK,KAAMe,EAAO,IAClBf,KAAK,eArEkB,GAsEvBA,KAAK,SAAU,SAEpB,cAAuB6B,EAAvB,eAAiC,CAA5B,IAAMM,EAAQ,KACfrC,EAAIsC,UAAJ,aACKC,KAAKF,GACLG,QACAvC,OAAO,QACPsB,MAAM,QAAQ,SAAAF,GAAC,OAAIA,EAAER,SACrBX,KAAK,KAAK,SAAAmB,GAAC,OAAIC,EAAOD,EAAEvN,SACxBoM,KAAK,QAASkC,GACdlC,KAAK,KAAK,SAAAmB,GAAC,OAAIJ,EAAOI,EAAEa,WACxBhC,KAAK,UAAU,SAAAmB,GAAC,OAAIJ,EAAOI,EAAEc,MAAQlB,EAAOI,EAAEa,gBA3F/D,K,gBCuBeO,I,2EAAf,4BAAAtO,EAAA,6DACI6B,EAAuB0M,UAAU,QAC3BlI,EAAWxE,EAAuBiC,cAF5C,SAGUuC,EAASmI,8BAA8B,OAHjD,OAIIC,QAAQC,IAAI,uCAJhB,4C,sBAOO,I,EAAMC,EAAb,kDACI,WAAYC,GAAQ,IAAD,8BACf,cAAMA,IAEDC,YAAcC,IAAMC,YACzB,EAAKC,aAAeF,IAAMC,YAJX,EADvB,sDAQI,WACI,OAAO,IAAIhF,EACPrI,KAAKkN,MAAMK,GACXvN,KAAKkN,MAAMM,GACXxN,KAAKkN,MAAMO,IACXzN,KAAKkN,MAAMQ,IACX,CAAE1D,IAAK,GACP,CACI1G,cAAetD,KAAKkN,MAAMS,IAC1BrI,YAhCYsI,EAgCmB5N,KAAKkN,MA/B5CU,EAAMC,IACC,CAAE5K,gBAAiB,EAAKC,WAAY0K,EAAME,KAE1C,CAAE7K,gBAAiB2K,EAAME,IAA+B5K,WAAY,KA8BvElD,KAAKkN,MAAMa,IACX/N,KAAKkN,MAAMc,KAnCvB,IAA4BJ,IAe5B,+BAwBI,WACI,IAAMK,EAAkBjO,KAAKkO,sBAC7B,IAAIrE,GAAcsE,OAAOF,EAAgB1J,gBAAiBvE,KAAKmN,YAAYiB,UAC3E,IAAInC,GAAmBkC,OAAOF,EAAgB1J,gBAAiBvE,KAAKsN,aAAac,WA3BzF,sEA8BI,sBAAA9P,EAAA,sEACUsO,IADV,OAEI5M,KAAKqO,oBAFT,gDA9BJ,sFAmCI,WACIrO,KAAKqO,sBApCb,oBAsCI,WACI,OACI,eAAC,IAAMC,SAAP,WACI,qBAAKC,IAAKvO,KAAKmN,cACf,qBAAKoB,IAAKvO,KAAKsN,sBA1C/B,GAAmCF,IAAMoB,WC7B5BjB,EAA8B,kBAC9BC,EAAgC,oBAChCM,GAA+B,mBAC/BD,GAAoC,uBACpCH,GAA0B,cAC1BK,GAAiB,MACjBJ,GAA6B,gBAC7BF,GAA4B,gBAC5BO,GAAmB,kBAE1BS,IAAiB,mBAClBlB,EAA8B,oBADZ,cAElBC,EAAgC,sBAFd,cAGlBM,GAA+B,qBAHb,cAIlBD,GAAoC,gBAJlB,cAKlBH,GAA0B,gBALR,cAMlBK,GAAiB,YANC,cAOlBJ,GAA6B,mBAPX,cAQlBF,GAA4B,kBARV,cASlBO,GAAmB,oBATD,GAYvB,SAASU,GAAoBxD,EAAGyD,GAC5B,IAAMC,EAASC,SAAS3D,EAAE4D,OAAOjJ,OACjC,OAAOkJ,MAAMH,GAAU,EAAIA,EAG/B,SAASI,GAAsB9D,EAAGyD,GAC9B,IAAMC,EAAS/P,WAAWqM,EAAE4D,OAAOjJ,OACnC,OAAOkJ,MAAMH,GAAU,EAAIA,EAG/B,SAASK,GAAuB/D,EAAGyD,GAC/B,OAAQA,EAAOzB,MAAMrH,M,IAWnBqJ,G,kDACF,WAAYhC,GAAQ,IAAD,gCACf,cAAMA,IACDU,OAAL,mBACKL,EAA8B,CAAE1H,MAAO,IAAMsJ,KAAM,OAAQC,kBAAmBV,KADnF,cAEKlB,EAAgC,CAAE3H,MAAO,IAAKsJ,KAAM,OAAQC,kBAAmBV,KAFpF,cAGKjB,GAA4B,CAAE5H,MAAO,IAAMsJ,KAAM,OAAQC,kBAAmBV,KAHjF,cAIKZ,GAA+B,CAAEjI,MAAO,KAAOsJ,KAAM,OAAQC,kBAAmBJ,KAJrF,cAKKnB,GAAoC,CACjChI,OAAO,EACPsJ,KAAM,WACNC,kBAAmBH,KAR3B,cAUKvB,GAA0B,CAAE7H,MAAO,GAAIsJ,KAAM,OAAQC,kBAAmBV,KAV7E,cAWKX,GAAiB,CAAElI,MAAO,GAAIsJ,KAAM,OAAQC,kBAAmBV,KAXpE,cAYKf,GAA6B,CAAE9H,MAAO,IAAKsJ,KAAM,OAAQC,kBAAmBV,KAZjF,cAaKV,GAAmB,CAAEnI,MAAO,GAAIsJ,KAAM,OAAQC,kBAAmBV,KAbtE,GAgBA,EAAKW,aAAe,EAAKA,aAAaC,KAAlB,gBAlBL,E,gDAqBnB,SAAaC,EAAcC,GACvB,IAAMC,EAAa,eAAQzP,KAAK4N,MAAM4B,IACtCC,EAAc5J,MAAQ0J,EACtBvP,KAAK0P,SAAL,eAAiBF,EAAyBC,IAC1C1C,QAAQC,IAAR,gBAAqBwC,EAArB,6BAAgED,EAAhE,Q,oBAGJ,WAAU,IAAD,OACCI,EAtCd,SAAqC/B,GACjC,IAAMV,EAAQ,GACd,IAAK,IAAM0C,KAAchC,EACrBV,EAAM0C,GAAchC,EAAMgC,GAAY/J,MAE1C,OAAOqH,EAiCwB2C,CAA4B7P,KAAK4N,OAC5D,OACI,eAAC,IAAMU,SAAP,WACI,+BACKwB,OAAOC,KAAK/P,KAAK4N,OAAOzO,KAAI,SAAA6Q,GAAe,OACxC,cAAC,GAAD,CAEIC,MAAOxB,GAAkBuB,GACzBnK,MAAO,EAAK+H,MAAMoC,GAAiBnK,MACnCsJ,KAAM,EAAKvB,MAAMoC,GAAiBb,KAClCe,cAAe,EAAKb,aACpBW,gBAAiBA,EACjBZ,kBAAmB,EAAKxB,MAAMoC,GAAiBZ,mBAN1CY,QAUjB,cAAC,EAAD,eAAmBL,W,GA9CXvC,IAAMoB,WAoDxB2B,G,kDACF,WAAYjD,GAAQ,IAAD,8BACf,cAAMA,IACDmC,aAAe,EAAKA,aAAaC,KAAlB,gBAFL,E,gDAKnB,SAAapE,GACTlL,KAAKkN,MAAMgD,cAAclQ,KAAKkN,MAAMkC,kBAAkBlE,EAAGlL,MAAOA,KAAKkN,MAAM8C,mB,oBAG/E,WACI,OACI,kCACKhQ,KAAKkN,MAAM+C,MACZ,uBAAOd,KAAMnP,KAAKkN,MAAMiC,KAAMtJ,MAAO7F,KAAKkN,MAAMrH,MAAOuK,SAAUpQ,KAAKqP,sB,GAdvDjC,IAAMoB,WAoBtBU,MC7GAmB,OARf,WACI,OACI,qBAAKC,UAAU,QAAf,SACI,cAAC,GAAD,OCOGC,GAZS,SAAAC,GAClBA,GAAeA,aAAuBC,UACxC,8BAAqBC,MAAK,YAAkD,IAA/CC,EAA8C,EAA9CA,OAAQC,EAAsC,EAAtCA,OAAQC,EAA8B,EAA9BA,OAAQC,EAAsB,EAAtBA,OAAQC,EAAc,EAAdA,QAC3DJ,EAAOH,GACPI,EAAOJ,GACPK,EAAOL,GACPM,EAAON,GACPO,EAAQP,OCDdQ,IAAS7C,OACL,cAAC,IAAM8C,WAAP,UACI,cAAC,GAAD,MAEJC,SAASC,eAAe,SAM5BZ,O","file":"static/js/main.f735fd13.chunk.js","sourcesContent":["import * as d3 from 'd3';\n\n// Ignore milliseconds, seconds, minutes.\nconst timeDiffIgnoreDivisor = 1000 * 60 * 60 * 24;\n\nexport const timestampIndexOfForecastArray = 0;\nexport const courseIndexOfForecastArray = 1;\nexport const numberOfMonthsOfAYear = 12;\nexport const inflationRate = 0.01;\n\nexport function isLastMonthOfAYear(date) {\n    return date.getMonth() === numberOfMonthsOfAYear - 1;\n}\n\nexport function clamp(value, min, max) {\n    return Math.max(min, Math.min(value, max));\n}\n\nexport function isFirstMonthOfAYear(date) {\n    return date.getMonth() === 0;\n}\n\nexport async function loadHistoricalETFData(etfIdentifier, apiKey) {\n    const historicalData = await d3.csv(\n        `https://www.alphavantage.co/query?function=TIME_SERIES_MONTHLY_ADJUSTED&symbol=${etfIdentifier}&apikey=${apiKey}&datatype=csv`,\n        entry => {\n            return {\n                date: new Date(entry.timestamp.toString()),\n                dividend: parseFloat(entry['dividend amount']),\n                course: parseFloat(entry['adjusted close']),\n            };\n        }\n    );\n    historicalData.sort((a, b) => a.date - b.date);\n    return historicalData;\n}\n\nexport function etfHistoricalToCourseForecastArray(historicalData) {\n    return historicalData.map(entry => [dateToTimestamp(entry.date), entry.course]);\n}\n\n// Requires sorted historical data. Note it is sorted by default. Do not change the order.\nexport function etfHistoricalToDividendForecastArray(historicalData) {\n    let currentYear = historicalData[0].date.getFullYear();\n    const dividendForecastArray = [[currentYear, 0]];\n    historicalData.forEach(entry => {\n        if (entry.date.getFullYear() === currentYear) {\n            dividendForecastArray[dividendForecastArray.length - 1][courseIndexOfForecastArray] += entry.dividend;\n        } else {\n            currentYear = entry.date.getFullYear();\n            dividendForecastArray.push([currentYear, entry.dividend]);\n        }\n    });\n    dividendForecastArray.sort((a, b) => a[timestampIndexOfForecastArray] - b[timestampIndexOfForecastArray]);\n    return dividendForecastArray;\n}\n\nexport function dateToTimestamp(date) {\n    return Math.floor(date.getTime() / timeDiffIgnoreDivisor);\n}\n\nexport function timestampToDate(timestamp) {\n    return new Date(timestamp * timeDiffIgnoreDivisor);\n}\n\nexport function HistoricalDataNotPresentException(etfIdentifier) {\n    this.message = `First call loadHistoricalDataIfNotPresent() before predicting: ${etfIdentifier}`;\n    this.name = 'HistoricalDataNotPresentException';\n}\n","import regression from 'regression';\nimport {\n    dateToTimestamp,\n    etfHistoricalToCourseForecastArray,\n    etfHistoricalToDividendForecastArray,\n    loadHistoricalETFData,\n    timestampIndexOfForecastArray,\n    courseIndexOfForecastArray,\n    HistoricalDataNotPresentException,\n} from '../helpers/utils';\n\n// USAGE: first call configure to set required static vars. Then the singleton can be accessed via getInstance. Never call the Constructor on your own.\n// Always call loadAndCacheHistoricalETFData of an etf before calling predict on that etf.\nexport class ForecastModelSingleton {\n    static instance = null;\n    static apiKey = null;\n    static backCastTimeConstant = null;\n    static backCastTimeFactor = null;\n\n    // DO NOT CALL. USE getInstance()\n    constructor() {\n        this.historicalData = {};\n        this.coursePredictors = {};\n        this.dividendPredictors = {};\n    }\n\n    static configure(apiKey, backCastTimeFactor = 2, backCastTimeConstant = 7) {\n        ForecastModelSingleton.apiKey = apiKey;\n        ForecastModelSingleton.backCastTimeFactor = backCastTimeFactor;\n\n        const backCastTimeDate = new Date(0);\n        backCastTimeDate.setMonth(backCastTimeConstant);\n        ForecastModelSingleton.backCastTimestampConstant = dateToTimestamp(backCastTimeDate);\n\n        // reset predictors if present.\n        if (ForecastModelSingleton.instance != null) {\n            const instance = ForecastModelSingleton.getInstance();\n            for (const etfIdentifier in instance.coursePredictors) {\n                instance.coursePredictors[etfIdentifier] = {\n                    maxTimestampBeforeCoursePredictorRepetition: ForecastModelSingleton._calculateMaxTimestampBeforePredictorRepetition(\n                        instance.historicalData[etfIdentifier].courseForecastArray\n                    ),\n                };\n            }\n            for (const etfIdentifier in instance.dividendPredictors) {\n                instance.dividendPredictors[etfIdentifier] = {\n                    maxYearBeforeDividendPredictorRepetition: ForecastModelSingleton._calculateMaxTimestampBeforePredictorRepetition(\n                        instance.historicalData[etfIdentifier].dividendForecastArray\n                    ),\n                };\n            }\n        }\n    }\n\n    static getInstance() {\n        if (ForecastModelSingleton.instance == null) {\n            ForecastModelSingleton.instance = new ForecastModelSingleton();\n        }\n        return ForecastModelSingleton.instance;\n    }\n\n    static _calculateMaxTimestampBeforePredictorRepetition(forecastArray) {\n        const firstTimestamp = forecastArray[0][timestampIndexOfForecastArray];\n        const lastTimestamp = forecastArray[forecastArray.length - 1][timestampIndexOfForecastArray];\n        return lastTimestamp + (lastTimestamp - firstTimestamp) / ForecastModelSingleton.backCastTimeFactor;\n    }\n\n    async loadAndCacheHistoricalETFData(etfIdentifier) {\n        if (etfIdentifier in this.historicalData) {\n            return;\n        }\n        const historicalData = await loadHistoricalETFData(etfIdentifier);\n\n        const courseForecastArray = etfHistoricalToCourseForecastArray(historicalData);\n        const maxTimestampBeforeCoursePredictorRepetition = ForecastModelSingleton._calculateMaxTimestampBeforePredictorRepetition(\n            courseForecastArray\n        );\n\n        const dividendForecastArray = etfHistoricalToDividendForecastArray(historicalData);\n        const maxYearBeforeDividendPredictorRepetition = ForecastModelSingleton._calculateMaxTimestampBeforePredictorRepetition(\n            dividendForecastArray\n        );\n\n        this.historicalData[etfIdentifier] = {\n            history: historicalData,\n            courseForecastArray: courseForecastArray,\n            dividendForecastArray: dividendForecastArray,\n        };\n        this.coursePredictors[etfIdentifier] = {\n            maxTimestampBeforeCoursePredictorRepetition: maxTimestampBeforeCoursePredictorRepetition,\n        };\n        this.dividendPredictors[etfIdentifier] = {\n            maxYearBeforeDividendPredictorRepetition: maxYearBeforeDividendPredictorRepetition,\n        };\n    }\n\n    _createCoursePredictorIfNotPresent(etfIdentifier, timestamp) {\n        // Skip if already exists.\n        if (timestamp in this.coursePredictors[etfIdentifier]) {\n            return;\n        }\n        const forecastArray = this.historicalData[etfIdentifier].courseForecastArray;\n        const lastTimestampToIncludeInPrediction =\n            forecastArray[forecastArray.length - 1][timestampIndexOfForecastArray] -\n            Math.abs(forecastArray[forecastArray.length - 1][timestampIndexOfForecastArray] - timestamp) *\n                ForecastModelSingleton.backCastTimeFactor -\n            ForecastModelSingleton.backCastTimestampConstant;\n        const filteredForecastArray = forecastArray.filter(\n            entry => entry[timestampIndexOfForecastArray] >= lastTimestampToIncludeInPrediction\n        );\n        this.coursePredictors[etfIdentifier][timestamp] = regression.linear(filteredForecastArray, {\n            order: 2,\n            precision: 20,\n        });\n    }\n\n    _courseDateToPredictorTimestampAndDateTimestamp(date, etfIdentifier) {\n        const timestamp = dateToTimestamp(date);\n        return [\n            timestamp > this.coursePredictors[etfIdentifier].maxTimestampBeforeCoursePredictorRepetition\n                ? this.coursePredictors[etfIdentifier].maxTimestampBeforeCoursePredictorRepetition\n                : timestamp,\n            timestamp,\n        ];\n    }\n\n    _createDividendPredictorIfNotPresent(etfIdentifier, year) {\n        // Skip if already exists.\n        if (year in this.dividendPredictors[etfIdentifier]) {\n            return;\n        }\n        const forecastArray = this.historicalData[etfIdentifier].dividendForecastArray;\n        const lastYearToIncludeInPrediction =\n            forecastArray[forecastArray.length - 1][timestampIndexOfForecastArray] -\n            Math.abs(forecastArray[forecastArray.length - 1][timestampIndexOfForecastArray] - year) *\n                ForecastModelSingleton.backCastTimeFactor -\n            ForecastModelSingleton.backCastTimestampConstant;\n        const filteredForecastArray = forecastArray.filter(\n            entry => entry[timestampIndexOfForecastArray] >= lastYearToIncludeInPrediction\n        );\n        this.dividendPredictors[etfIdentifier][year] = regression.linear(filteredForecastArray, {\n            order: 2,\n            precision: 20,\n        });\n    }\n\n    _dividendYearToPredictorYear(etfIdentifier, year) {\n        return this.dividendPredictors[etfIdentifier].maxYearBeforeDividendPredictorRepetition < year\n            ? this.dividendPredictors[etfIdentifier].maxYearBeforeDividendPredictorRepetition\n            : year;\n    }\n\n    predictCourse(etfIdentifier, date) {\n        if (!(etfIdentifier in this.coursePredictors)) {\n            throw new HistoricalDataNotPresentException(etfIdentifier);\n        }\n        const [predictorTimestamp, timestamp] = this._courseDateToPredictorTimestampAndDateTimestamp(\n            date,\n            etfIdentifier\n        );\n        this._createCoursePredictorIfNotPresent(etfIdentifier, predictorTimestamp);\n        return this.coursePredictors[etfIdentifier][predictorTimestamp].predict(timestamp)[courseIndexOfForecastArray];\n    }\n\n    predictDividend(etfIdentifier, year) {\n        if (!(etfIdentifier in this.dividendPredictors)) {\n            throw new HistoricalDataNotPresentException(etfIdentifier);\n        }\n        const predictorYear = this._dividendYearToPredictorYear(etfIdentifier, year);\n        this._createDividendPredictorIfNotPresent(etfIdentifier, predictorYear);\n        return Math.max(\n            0,\n            this.dividendPredictors[etfIdentifier][predictorYear].predict(year)[courseIndexOfForecastArray]\n        );\n    }\n}\n\nexport default ForecastModelSingleton;\n","import ForecastModelSingleton from './ForecastModel';\nimport { numberOfMonthsOfAYear, isLastMonthOfAYear, clamp, isFirstMonthOfAYear } from '../helpers/utils';\n\nconst basicRateOfInterest = 0.007;\nconst partialExemption = 0.7;\nconst corporateTaxRatio = 0.26375;\nconst inflationRate = 0.01;\n\nfunction getNextMonthDate(date) {\n    const newDate = new Date(date);\n    newDate.setMonth(date.getMonth() + 1);\n    return newDate;\n}\n\nfunction calculateDividend(etfIdentifier, date) {\n    if (!isLastMonthOfAYear(date)) {\n        return 0;\n    } else {\n        return ForecastModelSingleton.getInstance().predictDividend(etfIdentifier, date.getFullYear());\n    }\n}\n\nfunction calculateCosts(amount, costConfiguration) {\n    let costs = amount * costConfiguration.percentageCosts + costConfiguration.fixedCosts;\n    const amountWithoutCosts = Math.max(amount - costs, 0);\n    costs = amount - amountWithoutCosts;\n    return [amountWithoutCosts, costs];\n}\n\nfunction subtractTaxFreeGain(taxAmount, taxFreeAmount) {\n    const leftoverTaxes = Math.max(0, taxAmount - taxFreeAmount);\n    const leftoverTaxFreeAmount = Math.max(0, taxFreeAmount - taxAmount);\n    return [leftoverTaxes, leftoverTaxFreeAmount];\n}\n\nexport function getTotalShareValue(etfIdentifier, investmentStep) {\n    return investmentStep.totalShares[etfIdentifier] * investmentStep.sharePrizes[etfIdentifier];\n}\n\nfunction getNewShareValue(etfIdentifier, investmentStep) {\n    return investmentStep.newShares[etfIdentifier] * investmentStep.sharePrizes[etfIdentifier];\n}\n\nfunction sumOfTotalValues(investmentStep) {\n    let sum = 0;\n    for (const etfIdentifier in investmentStep.totalShares) {\n        sum += getTotalShareValue(etfIdentifier, investmentStep);\n    }\n    return sum;\n}\n\nfunction calculateAndAddInflation(investmentStep, initialDate, endDate) {\n    // TODO predict inflationRate??? if so how should I predict it?\n    const sumTotalValues = sumOfTotalValues(investmentStep);\n    const timeFactor =\n        endDate.getFullYear() -\n        initialDate.getFullYear() +\n        (endDate.getMonth() - initialDate.getMonth()) / numberOfMonthsOfAYear;\n    investmentStep.inflation = sumTotalValues - sumTotalValues * Math.pow(1 - inflationRate, timeFactor);\n}\n\nfunction calculateForecastInterval(age, lifeExpectation, savingPhaseLength, fadeOutYears = 10) {\n    const yearsLeft = lifeExpectation - age;\n    const now = new Date();\n    const beginningDate = new Date(now.getFullYear(), now.getMonth() + 1);\n    // start next month.\n    const endSavingPhaseDate = new Date(beginningDate);\n    endSavingPhaseDate.setFullYear(beginningDate.getFullYear() + savingPhaseLength);\n    const endDate = new Date(beginningDate);\n    endDate.setFullYear(beginningDate.getFullYear() + yearsLeft + fadeOutYears);\n    return [beginningDate, endSavingPhaseDate, endDate];\n}\n\nfunction calculateTaxes(investmentSteps, date, leftoverTaxFreeAmount, etfToRatio) {\n    if (!isFirstMonthOfAYear(date) || investmentSteps.length < 2) {\n        return [0, leftoverTaxFreeAmount];\n    }\n    let summedTaxes = 0;\n    const decemberInvestmentStep = investmentSteps[investmentSteps.length - 1];\n    // Use the second investment step if there are not enough meaning the investing started this year after january.\n    // The second is the true first investment step the first is a dummy.\n    const firstInvestmentStepOfThisYear =\n        investmentSteps.length - numberOfMonthsOfAYear > 1\n            ? investmentSteps[investmentSteps.length - numberOfMonthsOfAYear]\n            : investmentSteps[1];\n    for (const etfIdentifier in etfToRatio) {\n        let accumulatedBasicProfit = 0;\n        // Sum up all new investments from february to december.\n        for (let i = 1; i < numberOfMonthsOfAYear && investmentSteps.length - i > 0; i++) {\n            const currentInvestmentStep = investmentSteps[investmentSteps.length - i];\n            accumulatedBasicProfit +=\n                (getNewShareValue(etfIdentifier, currentInvestmentStep) * i) / numberOfMonthsOfAYear;\n        }\n        // Sum up total Investment of the first date of this year.\n        accumulatedBasicProfit +=\n            (getTotalShareValue(etfIdentifier, firstInvestmentStepOfThisYear) *\n                (numberOfMonthsOfAYear - firstInvestmentStepOfThisYear.date.getMonth())) /\n            numberOfMonthsOfAYear;\n        accumulatedBasicProfit *= 0.7 * basicRateOfInterest;\n        const currentShareValues = getTotalShareValue(etfIdentifier, decemberInvestmentStep);\n        // Calculate profit of last year.\n        const profitOverAllTime = currentShareValues - decemberInvestmentStep.totalInvestedMoney[etfIdentifier];\n        let profitOfPreviousYears = 0;\n        if (investmentSteps.length > numberOfMonthsOfAYear) {\n            profitOfPreviousYears = Math.max(\n                0,\n                getTotalShareValue(etfIdentifier, investmentSteps[investmentSteps.length - 1 - numberOfMonthsOfAYear]) -\n                    investmentSteps[investmentSteps.length - 1 - numberOfMonthsOfAYear].totalInvestedMoney[\n                        etfIdentifier\n                    ]\n            );\n        }\n\n        const profitOfThisYear = profitOverAllTime - profitOfPreviousYears;\n        let amountToApplyTaxes = clamp(profitOfThisYear, 0, accumulatedBasicProfit);\n        [amountToApplyTaxes, leftoverTaxFreeAmount] = subtractTaxFreeGain(amountToApplyTaxes, leftoverTaxFreeAmount);\n        summedTaxes += amountToApplyTaxes * partialExemption * corporateTaxRatio;\n    }\n    return [summedTaxes, leftoverTaxFreeAmount];\n}\n\nexport function addAccumulationMonth(investmentSteps, investment, date, initialDate, etfToRatio, configOptions) {\n    const forecast = ForecastModelSingleton.getInstance();\n    let costs = 0;\n    const prevInvestmentStep = investmentSteps[investmentSteps.length - 1];\n    const newInvestmentStep = {\n        date: date,\n        newShares: {},\n        totalShares: { ...prevInvestmentStep.totalShares },\n        dividendNewShares: {},\n        dividendTotalShares: { ...prevInvestmentStep.dividendTotalShares },\n        totalCosts: prevInvestmentStep.totalCosts,\n        sharePrizes: {},\n        totalInvestedMoney: { ...prevInvestmentStep.totalInvestedMoney },\n        newInvestedMoney: {},\n        totalTaxes: prevInvestmentStep.totalTaxes,\n        totalPayout: { ...prevInvestmentStep.totalPayout },\n        newPayout: {},\n    };\n    for (const etfIdentifier in etfToRatio) {\n        const investmentOfEtfWithCosts = etfToRatio[etfIdentifier] * investment;\n        const [investmentOfEtfWithoutCosts, newCosts] = calculateCosts(\n            investmentOfEtfWithCosts,\n            configOptions.costConfig\n        );\n        costs += newCosts;\n        newInvestmentStep.newInvestedMoney[etfIdentifier] = investmentOfEtfWithoutCosts;\n        newInvestmentStep.totalInvestedMoney[etfIdentifier] += investmentOfEtfWithoutCosts;\n\n        const etfSharePrize = forecast.predictCourse(etfIdentifier, date);\n        const newShares = investmentOfEtfWithoutCosts / etfSharePrize;\n        newInvestmentStep.sharePrizes[etfIdentifier] = etfSharePrize;\n        newInvestmentStep.newShares[etfIdentifier] = newShares;\n\n        const dividendPayoutMoneyPerShare = calculateDividend(etfIdentifier, date);\n        const dividendPayoutMoney = newInvestmentStep.totalShares[etfIdentifier] * dividendPayoutMoneyPerShare;\n        const newSharesByDividend = dividendPayoutMoney / etfSharePrize;\n        newInvestmentStep.newShares[etfIdentifier] += newSharesByDividend;\n        newInvestmentStep.dividendNewShares[etfIdentifier] = newSharesByDividend;\n        newInvestmentStep.dividendTotalShares[etfIdentifier] += newSharesByDividend;\n\n        newInvestmentStep.totalShares[etfIdentifier] += newInvestmentStep.newShares[etfIdentifier];\n        newInvestmentStep.newPayout[etfIdentifier] = 0;\n    }\n    newInvestmentStep.totalCosts += costs;\n    const [newTaxes, newLeftoverTaxFreeAmount] = calculateTaxes(\n        investmentSteps,\n        date,\n        configOptions.taxFreeAmount,\n        etfToRatio\n    );\n    newInvestmentStep.totalTaxes += newTaxes;\n    calculateAndAddInflation(newInvestmentStep, initialDate, date);\n    investmentSteps.push(newInvestmentStep);\n\n    return newLeftoverTaxFreeAmount;\n}\n\nfunction addPayoutMonth(\n    investmentSteps,\n    sellingAmount,\n    etfToRatio,\n    date,\n    initialDate,\n    configOptions,\n    leftoverAlreadyPaidTaxes,\n    leftoverTaxFreeAmount,\n    payoutStats\n) {\n    if (isFirstMonthOfAYear(date)) {\n        leftoverTaxFreeAmount = configOptions.taxFreeAmount;\n    }\n    const forecast = ForecastModelSingleton.getInstance();\n    let costs = 0;\n    let taxes = 0;\n    const prevInvestmentStep = investmentSteps[investmentSteps.length - 1];\n    const newInvestmentStep = {\n        date: date,\n        newShares: {},\n        totalShares: { ...prevInvestmentStep.totalShares },\n        dividendNewShares: {},\n        dividendTotalShares: { ...prevInvestmentStep.dividendTotalShares },\n        totalCosts: prevInvestmentStep.totalCosts,\n        sharePrizes: {},\n        totalInvestedMoney: { ...prevInvestmentStep.totalInvestedMoney },\n        newInvestedMoney: {},\n        totalTaxes: prevInvestmentStep.totalTaxes,\n        totalPayout: { ...prevInvestmentStep.totalPayout },\n        newPayout: {},\n    };\n    for (const etfIdentifier in etfToRatio) {\n        const etfSharePrize = forecast.predictCourse(etfIdentifier, date);\n        newInvestmentStep.sharePrizes[etfIdentifier] = etfSharePrize;\n        newInvestmentStep.newPayout[etfIdentifier] = 0;\n        newInvestmentStep.newInvestedMoney[etfIdentifier] = 0;\n        // Skip payout if there are no shares left to sell.\n        if (payoutStats[etfIdentifier].investmentStepsIdx < investmentSteps.length) {\n            // Handle payout.\n            const amountToSell = sellingAmount * etfToRatio[etfIdentifier];\n            let amountAlreadySold = 0;\n            const costsToPay = calculateCosts(amountToSell, configOptions.costConfig)[1];\n            let alreadyPaidCosts = 0;\n            let payoutInvestmentStepIdxForFIFO = payoutStats[etfIdentifier].investmentStepsIdx;\n            let currentSharesLeft =\n                investmentSteps[payoutInvestmentStepIdxForFIFO].newShares[etfIdentifier] -\n                payoutStats[etfIdentifier].alreadySoldShares;\n            for (; payoutInvestmentStepIdxForFIFO < investmentSteps.length; payoutInvestmentStepIdxForFIFO++) {\n                const leftoverAmountToSell = amountToSell - amountAlreadySold;\n                const currentInvestmentStepForFIFO = investmentSteps[payoutInvestmentStepIdxForFIFO];\n\n                const currentValueOfShares =\n                    etfSharePrize *\n                    (payoutInvestmentStepIdxForFIFO === payoutStats[etfIdentifier].investmentStepsIdx\n                        ? currentInvestmentStepForFIFO.newShares[etfIdentifier] -\n                          payoutStats[etfIdentifier].alreadySoldShares\n                        : currentInvestmentStepForFIFO.newShares[etfIdentifier]);\n                const amountToSellWithCosts = Math.min(currentValueOfShares, leftoverAmountToSell);\n                const amountOfSharesToSell = amountToSellWithCosts / etfSharePrize;\n                currentSharesLeft = currentInvestmentStepForFIFO.newShares[etfIdentifier] - amountOfSharesToSell;\n                currentSharesLeft -=\n                    payoutInvestmentStepIdxForFIFO === payoutStats[etfIdentifier].investmentStepsIdx\n                        ? payoutStats[etfIdentifier].alreadySoldShares\n                        : 0;\n\n                const amountToSellWithoutCosts = Math.max(0, amountToSellWithCosts - (costsToPay - alreadyPaidCosts));\n                alreadyPaidCosts += Math.max(0, amountToSellWithCosts - amountToSellWithoutCosts);\n\n                const initialValueOfShares =\n                    amountOfSharesToSell * currentInvestmentStepForFIFO.sharePrizes[etfIdentifier];\n                let amountToPayTaxes = Math.max(0, amountToSellWithoutCosts - initialValueOfShares);\n\n                [amountToPayTaxes, leftoverTaxFreeAmount] = subtractTaxFreeGain(\n                    amountToPayTaxes,\n                    leftoverTaxFreeAmount\n                );\n                let taxesToPay = amountToPayTaxes * partialExemption * corporateTaxRatio;\n                [taxesToPay, leftoverAlreadyPaidTaxes] = subtractTaxFreeGain(taxesToPay, leftoverAlreadyPaidTaxes);\n                taxes += taxesToPay;\n                const payoutAmount = amountToSellWithoutCosts - taxesToPay;\n\n                newInvestmentStep.newPayout[etfIdentifier] += payoutAmount;\n                newInvestmentStep.totalPayout[etfIdentifier] += payoutAmount;\n\n                newInvestmentStep.totalShares[etfIdentifier] -= amountOfSharesToSell;\n                amountAlreadySold += amountToSellWithCosts;\n\n                // Handle the decrease of the dividendShares.\n                let amountOfDividendSharesLeft = 0;\n                if (payoutInvestmentStepIdxForFIFO === payoutStats[etfIdentifier].investmentStepsIdx) {\n                    amountOfDividendSharesLeft = Math.max(\n                        0,\n                        currentInvestmentStepForFIFO.dividendNewShares[etfIdentifier] -\n                            payoutStats[etfIdentifier].alreadySoldShares\n                    );\n                } else {\n                    amountOfDividendSharesLeft = currentInvestmentStepForFIFO.dividendNewShares[etfIdentifier];\n                }\n                const amountOfDividendSharesSold = Math.min(amountOfDividendSharesLeft, amountOfSharesToSell);\n                newInvestmentStep.dividendTotalShares[etfIdentifier] -= amountOfDividendSharesSold;\n\n                // Use break in order to not change the value of payoutInvestmentStepIdxForFIFO.\n                if (amountAlreadySold >= amountToSell) {\n                    break;\n                }\n            }\n            costs += alreadyPaidCosts;\n            // Handle update payoutStats.\n            payoutStats[etfIdentifier].investmentStepsIdx = payoutInvestmentStepIdxForFIFO;\n            payoutStats[etfIdentifier].investmentStepsIdx += currentSharesLeft === 0 ? 1 : 0;\n\n            payoutStats[etfIdentifier].alreadySoldShares =\n                payoutInvestmentStepIdxForFIFO < investmentSteps.length\n                    ? investmentSteps[payoutInvestmentStepIdxForFIFO].newShares[etfIdentifier] - currentSharesLeft\n                    : 0;\n        }\n\n        // Handle dividend.\n        const dividendPayoutMoney =\n            newInvestmentStep.totalShares[etfIdentifier] * calculateDividend(etfIdentifier, date);\n        const newSharesByDividend = dividendPayoutMoney / etfSharePrize;\n        newInvestmentStep.newShares[etfIdentifier] = newSharesByDividend;\n        newInvestmentStep.totalShares[etfIdentifier] += newSharesByDividend;\n        newInvestmentStep.dividendNewShares[etfIdentifier] = newSharesByDividend;\n        newInvestmentStep.dividendTotalShares[etfIdentifier] += newSharesByDividend;\n    }\n\n    newInvestmentStep.totalCosts += costs;\n    newInvestmentStep.totalTaxes += taxes;\n    calculateAndAddInflation(newInvestmentStep, initialDate, date);\n    investmentSteps.push(newInvestmentStep);\n    return [leftoverAlreadyPaidTaxes, leftoverTaxFreeAmount];\n}\n\nfunction generateEmptyInvestmentStep(etfToRatio, date) {\n    const forecast = ForecastModelSingleton.getInstance();\n    const emptyInvestmentStep = {\n        date: date,\n        totalCosts: 0,\n        totalTaxes: 0,\n        newShares: {},\n        totalShares: {},\n        dividendNewShares: {},\n        dividendTotalShares: {},\n        totalInvestedMoney: {},\n        totalPayout: {},\n        newPayout: {},\n        sharePrizes: {},\n    };\n    for (const etfIdentifier in etfToRatio) {\n        emptyInvestmentStep.newShares[etfIdentifier] = 0;\n        emptyInvestmentStep.totalShares[etfIdentifier] = 0;\n        emptyInvestmentStep.dividendNewShares[etfIdentifier] = 0;\n        emptyInvestmentStep.dividendTotalShares[etfIdentifier] = 0;\n        emptyInvestmentStep.totalInvestedMoney[etfIdentifier] = 0;\n        emptyInvestmentStep.totalPayout[etfIdentifier] = 0;\n        emptyInvestmentStep.newPayout[etfIdentifier] = 0;\n        emptyInvestmentStep.sharePrizes[etfIdentifier] = forecast.predictCourse(etfIdentifier, date);\n    }\n    return emptyInvestmentStep;\n}\n\nexport class InvestmentModel {\n    constructor(\n        startCapital,\n        monthlyInvestment,\n        monthlyPayout,\n        savingPhaseLength,\n        etfToRatio,\n        configOptions,\n        age,\n        expectationOfLife\n    ) {\n        this.startCapital = startCapital;\n        this.monthlyInvestment = monthlyInvestment;\n        this.monthlyPayout = monthlyPayout;\n        this.savingPhaseLength = savingPhaseLength;\n        this.etfToRatio = etfToRatio;\n        this.configOptions = configOptions;\n        this.expectationOfLife = expectationOfLife;\n        this.age = age;\n        this._calculateTimestampsForModel();\n        this._calculateModel();\n    }\n\n    _calculateTimestampsForModel() {\n        const [startDate, endSavingPhaseDate, endDate] = calculateForecastInterval(\n            this.age,\n            this.expectationOfLife,\n            this.savingPhaseLength\n        );\n        const savingDates = [];\n        for (\n            let currentDate = startDate;\n            currentDate < endSavingPhaseDate;\n            currentDate = getNextMonthDate(currentDate)\n        ) {\n            savingDates.push(currentDate);\n        }\n        this.savingDates = savingDates;\n        const payoutDates = [];\n        for (let currentDate = endSavingPhaseDate; currentDate < endDate; currentDate = getNextMonthDate(currentDate)) {\n            payoutDates.push(currentDate);\n        }\n        this.payoutDates = payoutDates;\n        this.initialDate = startDate;\n    }\n\n    _calculateModel() {\n        let investmentSteps = [generateEmptyInvestmentStep(this.etfToRatio, this.savingDates[0])];\n        let leftoverTaxFreeAmount = addAccumulationMonth(\n            investmentSteps,\n            this.monthlyInvestment + this.startCapital,\n            this.savingDates[0],\n            this.initialDate,\n            this.etfToRatio,\n            this.configOptions\n        );\n        for (const savingDate of this.savingDates.slice(1)) {\n            leftoverTaxFreeAmount = addAccumulationMonth(\n                investmentSteps,\n                this.monthlyInvestment,\n                savingDate,\n                this.initialDate,\n                this.etfToRatio,\n                this.configOptions\n            );\n        }\n        // Discard the empty investment step.\n        investmentSteps = investmentSteps.slice(1);\n\n        let leftoverAlreadyPaidTaxes = investmentSteps[investmentSteps.length - 1].totalTaxes;\n        const payoutStats = {};\n        for (const etfIdentifier in this.etfToRatio) {\n            payoutStats[etfIdentifier] = { investmentStepsIdx: 0, alreadySoldShares: 0 };\n        }\n        for (const payoutDate of this.payoutDates) {\n            [leftoverAlreadyPaidTaxes, leftoverTaxFreeAmount] = addPayoutMonth(\n                investmentSteps,\n                this.monthlyPayout,\n                this.etfToRatio,\n                payoutDate,\n                this.initialDate,\n                this.configOptions,\n                leftoverAlreadyPaidTaxes,\n                leftoverTaxFreeAmount,\n                payoutStats\n            );\n        }\n        this.investmentSteps = investmentSteps;\n    }\n}\n","import * as d3 from 'd3';\nimport { getTotalShareValue } from '../model/InvestmentModel';\n\nexport class LineChart3D {\n    render(investmentSteps, renderDivRef) {\n        const svgID = 'firstSVG';\n\n        const marginW = 150,\n            marginH = 40,\n            width = 1000,\n            height = 400;\n\n        const etfLineColors = { IBM: { total: '#0562a0', dividend: '#71c1f7' } };\n        const lineOpacity = 0.7;\n        const lineStrokeWidth = 3;\n\n        // Reset diagram by deletion.\n        renderDivRef.innerHTML = '';\n\n        const svg = d3\n            .select(renderDivRef)\n            .append('svg')\n            .attr('id', svgID)\n            .attr('height', '100%')\n            .attr('width', '100%')\n            .attr('viewBox', `0 0 ${width + 2 * marginW} ${height + 2 * marginH}`)\n            .append('g')\n            .attr('transform', `translate(${[marginW, marginH]})`);\n\n        // Create line array.\n        const dataToIndex = {\n            costs: 0,\n            taxes: 1,\n            inflation: 2,\n        };\n        let currentIdx = 3;\n        const capitalIdentifier = 'capital';\n        const dividendIdentifier = 'dividend';\n        for (const etfIdentifier in investmentSteps[0].totalShares) {\n            dataToIndex[etfIdentifier + dividendIdentifier] = currentIdx++;\n            dataToIndex[etfIdentifier + capitalIdentifier] = currentIdx++;\n        }\n\n        const lineData = [];\n        for (let i = 0; i < currentIdx; i++) {\n            lineData.push([]);\n        }\n        for (const investmentStep of investmentSteps) {\n            lineData[dataToIndex.costs].push({ value: -investmentStep.totalCosts, date: investmentStep.date });\n            lineData[dataToIndex.taxes].push({\n                value: -investmentStep.totalCosts - investmentStep.totalTaxes,\n                date: investmentStep.date,\n            });\n            lineData[dataToIndex.inflation].push({\n                value: -investmentStep.totalCosts - investmentStep.totalTaxes - investmentStep.inflation,\n                date: investmentStep.date,\n            });\n            let heightOffset = 0;\n            for (const etfIdentifier in investmentStep.totalShares) {\n                const totalShareValue = getTotalShareValue(etfIdentifier, investmentStep);\n                const totalDividendShareValue =\n                    investmentStep.dividendTotalShares[etfIdentifier] * investmentStep.sharePrizes[etfIdentifier];\n                lineData[dataToIndex[etfIdentifier + capitalIdentifier]].push({\n                    value: totalShareValue + heightOffset,\n                    date: investmentStep.date,\n                });\n                lineData[dataToIndex[etfIdentifier + dividendIdentifier]].push({\n                    value: totalShareValue - totalDividendShareValue + heightOffset,\n                    date: investmentStep.date,\n                });\n                heightOffset += totalShareValue;\n            }\n        }\n\n        // Append miscellaneous data to array.\n        lineData[dataToIndex.inflation].color = '#ff7f00';\n        lineData[dataToIndex.taxes].color = '#e31a1c';\n        lineData[dataToIndex.costs].color = '#be3bff';\n        for (const etfIdentifier in investmentSteps[0].totalShares) {\n            lineData[dataToIndex[etfIdentifier + dividendIdentifier]].color = etfLineColors[etfIdentifier].dividend;\n            lineData[dataToIndex[etfIdentifier + capitalIdentifier]].color = etfLineColors[etfIdentifier].total;\n        }\n\n        // Create scales.\n        const minVal = d3.min(lineData[dataToIndex.inflation].map(e => e.value));\n        const maxVal = d3.max(lineData[lineData.length - 1].map(e => e.value));\n\n        const yScale = d3.scaleLinear().domain([minVal, maxVal]).range([height, 0]);\n        const dateExtent = d3.extent(lineData[0], d => d.date);\n        const xScale = d3.scaleTime().domain(dateExtent).range([0, width]);\n\n        // Draw axis.\n        svg.append('g')\n            .style('font-size', '20px')\n            .call(d3.axisLeft(yScale).tickFormat(d => `${d.toLocaleString()} EUR`));\n\n        svg.append('g')\n            .style('font-size', '20px')\n            .attr('transform', `translate(0, ${height})`)\n            .call(d3.axisBottom(xScale));\n\n        // Draw zero line.\n        svg.append('g')\n            .append('line')\n            .attr('x1', xScale(dateExtent[0]))\n            .attr('y1', yScale(0))\n            .attr('x2', xScale(dateExtent[1]))\n            .attr('y2', yScale(0))\n            .style('stroke-width', lineStrokeWidth)\n            .style('stroke', 'black');\n\n        for (let i = 0; i < lineData.length; i++) {\n            svg.append('path')\n                .datum(lineData[i])\n                .style('stroke', d => d.color)\n                .style('stroke-width', lineStrokeWidth)\n                .style('opacity', lineOpacity)\n                .style('fill', 'none')\n                .attr(\n                    'd',\n                    d3\n                        .line()\n                        .x(d => xScale(d.date))\n                        .y(d => yScale(d.value))\n                );\n        }\n    }\n}\n\nexport default LineChart3D;\n","import * as d3 from 'd3';\n\nexport class CashflowBarChart {\n    render(investmentSteps, renderDivRef) {\n        const svgID = 'secondSVG';\n\n        const marginW = 150,\n            marginH = 40,\n            width = 1000,\n            height = 400;\n        const barPaddingPercentage = 0.9;\n\n        const zeroLineStrokeWidth = 3;\n\n        // Reset diagram by deletion.\n        renderDivRef.innerHTML = '';\n\n        const svg = d3\n            .select(renderDivRef)\n            .append('svg')\n            .attr('id', svgID)\n            .attr('height', '100%')\n            .attr('width', '100%')\n            .attr('viewBox', `0 0 ${width + 2 * marginW} ${height + 2 * marginH}`)\n            .append('g')\n            .attr('transform', `translate(${[marginW, marginH]})`);\n\n        // Create line array.\n        const dataToIndex = {\n            invested: 0,\n            payout: 1,\n        };\n\n        const rectData = [[], []];\n        for (const investmentStep of investmentSteps) {\n            let sumNewInvestedMoney = 0;\n            let sumNewPayout = 0;\n            for (const etfIdentifier in investmentStep.newInvestedMoney) {\n                sumNewInvestedMoney += investmentStep.newInvestedMoney[etfIdentifier];\n                sumNewPayout += investmentStep.newPayout[etfIdentifier];\n            }\n            rectData[dataToIndex.invested].push({\n                yStart: 0,\n                yEnd: -sumNewInvestedMoney,\n                date: investmentStep.date,\n                color: '#b4291f',\n            });\n            rectData[dataToIndex.payout].push({\n                yStart: sumNewPayout,\n                yEnd: 0,\n                date: investmentStep.date,\n                color: '#0562a0',\n            });\n        }\n\n        // Create scales.\n        const minVal = d3.min(rectData[dataToIndex.invested].map(e => e.yEnd));\n        const maxVal = d3.max(rectData[dataToIndex.payout].map(e => e.yStart));\n\n        const yScale = d3.scaleLinear().domain([minVal, maxVal]).range([height, 0]);\n        const dateExtent = d3.extent(rectData[dataToIndex.invested], d => d.date);\n        const xScale = d3.scaleTime().domain(dateExtent).range([0, width]);\n        const rectWidth = (width / rectData[dataToIndex.invested].length) * barPaddingPercentage;\n\n        // Draw axis.\n        svg.append('g')\n            .style('font-size', '20px')\n            .call(d3.axisLeft(yScale).tickFormat(d => `${d.toLocaleString()} EUR`));\n\n        svg.append('g')\n            .style('font-size', '20px')\n            .attr('transform', `translate(0, ${height})`)\n            .call(d3.axisBottom(xScale));\n\n        // Draw zero line.\n        svg.append('g')\n            .append('line')\n            .attr('x1', xScale(dateExtent[0]))\n            .attr('y1', yScale(0))\n            .attr('x2', xScale(dateExtent[1]))\n            .attr('y2', yScale(0))\n            .attr('stroke-width', zeroLineStrokeWidth)\n            .attr('stroke', 'black');\n\n        for (const barArray of rectData) {\n            svg.selectAll(`rect.none`)\n                .data(barArray)\n                .enter()\n                .append('rect')\n                .style('fill', d => d.color)\n                .attr('x', d => xScale(d.date))\n                .attr('width', rectWidth)\n                .attr('y', d => yScale(d.yStart))\n                .attr('height', d => yScale(d.yEnd) - yScale(d.yStart));\n        }\n    }\n}\n\nexport default CashflowBarChart;\n","import React from 'react';\nimport {\n    STARTING_CAPITAL_IDENTIFIER,\n    MONTHLY_INVESTMENT_IDENTIFIER,\n    TRANSACTION_COSTS_IDENTIFIER,\n    TRANSACTION_COSTS_TYPE_IDENTIFIER,\n    SAVING_PHASE_IDENTIFIER,\n    AGE_IDENTIFIER,\n    TAX_FREE_AMOUNT_IDENTIFIER,\n    MONTHLY_PAYOUT_IDENTIFIER,\n    LIFE_EXPECTATION,\n} from './InputForm';\nimport ForecastModelSingleton from '../model/ForecastModel';\nimport { InvestmentModel } from '../model/InvestmentModel';\nimport LineChart3D from '../renderer/LineChartd3';\nimport CashflowBarChart from '../renderer/CashflowBarChartd3';\n\nfunction generateCostConfig(state) {\n    if (state[TRANSACTION_COSTS_TYPE_IDENTIFIER]) {\n        return { percentageCosts: 0.0, fixedCosts: state[TRANSACTION_COSTS_IDENTIFIER] };\n    } else {\n        return { percentageCosts: state[TRANSACTION_COSTS_IDENTIFIER], fixedCosts: 0.0 };\n    }\n}\n\nasync function loadHistoricData() {\n    ForecastModelSingleton.configure('demo');\n    const forecast = ForecastModelSingleton.getInstance();\n    await forecast.loadAndCacheHistoricalETFData('IBM');\n    console.log('Finished loading the historic data.');\n}\n\nexport class Visualization extends React.Component {\n    constructor(props) {\n        super(props);\n\n        this.firstSVGRef = React.createRef();\n        this.secondSVGRef = React.createRef();\n    }\n\n    getInvestmentModel() {\n        return new InvestmentModel(\n            this.props[STARTING_CAPITAL_IDENTIFIER],\n            this.props[MONTHLY_INVESTMENT_IDENTIFIER],\n            this.props[MONTHLY_PAYOUT_IDENTIFIER],\n            this.props[SAVING_PHASE_IDENTIFIER],\n            { IBM: 1.0 },\n            {\n                taxFreeAmount: this.props[TAX_FREE_AMOUNT_IDENTIFIER],\n                costConfig: generateCostConfig(this.props),\n            },\n            this.props[AGE_IDENTIFIER],\n            this.props[LIFE_EXPECTATION]\n        );\n    }\n\n    drawVisualization() {\n        const investmentModel = this.getInvestmentModel();\n        new LineChart3D().render(investmentModel.investmentSteps, this.firstSVGRef.current);\n        new CashflowBarChart().render(investmentModel.investmentSteps, this.secondSVGRef.current);\n    }\n\n    async componentDidMount() {\n        await loadHistoricData();\n        this.drawVisualization();\n    }\n\n    componentDidUpdate() {\n        this.drawVisualization();\n    }\n    render() {\n        return (\n            <React.Fragment>\n                <div ref={this.firstSVGRef}></div>\n                <div ref={this.secondSVGRef}></div>\n            </React.Fragment>\n        );\n    }\n}\n","import React from 'react';\nimport { Visualization } from './Visualization';\n\nexport const STARTING_CAPITAL_IDENTIFIER = 'startingCapital';\nexport const MONTHLY_INVESTMENT_IDENTIFIER = 'monthlyInvestment';\nexport const TRANSACTION_COSTS_IDENTIFIER = 'transactionCosts';\nexport const TRANSACTION_COSTS_TYPE_IDENTIFIER = 'transactionCostsType';\nexport const SAVING_PHASE_IDENTIFIER = 'savingPhase';\nexport const AGE_IDENTIFIER = 'age';\nexport const TAX_FREE_AMOUNT_IDENTIFIER = 'taxFreeAmount';\nexport const MONTHLY_PAYOUT_IDENTIFIER = 'monthlyPayout';\nexport const LIFE_EXPECTATION = 'lifeExpectation';\n\nconst identifierToLabel = {\n    [STARTING_CAPITAL_IDENTIFIER]: 'Starting Capital',\n    [MONTHLY_INVESTMENT_IDENTIFIER]: 'Monthly Investment',\n    [TRANSACTION_COSTS_IDENTIFIER]: 'Transaction Costs',\n    [TRANSACTION_COSTS_TYPE_IDENTIFIER]: 'Fixes Amount',\n    [SAVING_PHASE_IDENTIFIER]: 'Saving Phase',\n    [AGE_IDENTIFIER]: 'Your Age',\n    [TAX_FREE_AMOUNT_IDENTIFIER]: 'Tax Free Amount',\n    [MONTHLY_PAYOUT_IDENTIFIER]: 'Monthly Payout',\n    [LIFE_EXPECTATION]: 'Life Expectation',\n};\n\nfunction transformInputToInt(e, caller) {\n    const intVal = parseInt(e.target.value);\n    return isNaN(intVal) ? 0 : intVal;\n}\n\nfunction transformInputToFloat(e, caller) {\n    const intVal = parseFloat(e.target.value);\n    return isNaN(intVal) ? 0 : intVal;\n}\n\nfunction transformCheckboxInput(e, caller) {\n    return !caller.props.value;\n}\n\nfunction constructVisualizationProps(state) {\n    const props = {};\n    for (const identifier in state) {\n        props[identifier] = state[identifier].value;\n    }\n    return props;\n}\n\nclass InputForm extends React.Component {\n    constructor(props) {\n        super(props);\n        this.state = {\n            [STARTING_CAPITAL_IDENTIFIER]: { value: 1000, type: 'text', transformFunction: transformInputToInt },\n            [MONTHLY_INVESTMENT_IDENTIFIER]: { value: 100, type: 'text', transformFunction: transformInputToInt },\n            [MONTHLY_PAYOUT_IDENTIFIER]: { value: 1000, type: 'text', transformFunction: transformInputToInt },\n            [TRANSACTION_COSTS_IDENTIFIER]: { value: 0.005, type: 'text', transformFunction: transformInputToFloat },\n            [TRANSACTION_COSTS_TYPE_IDENTIFIER]: {\n                value: false,\n                type: 'checkbox',\n                transformFunction: transformCheckboxInput,\n            },\n            [SAVING_PHASE_IDENTIFIER]: { value: 40, type: 'text', transformFunction: transformInputToInt },\n            [AGE_IDENTIFIER]: { value: 30, type: 'text', transformFunction: transformInputToInt },\n            [TAX_FREE_AMOUNT_IDENTIFIER]: { value: 801, type: 'text', transformFunction: transformInputToInt },\n            [LIFE_EXPECTATION]: { value: 80, type: 'text', transformFunction: transformInputToInt },\n        };\n\n        this.handleChange = this.handleChange.bind(this);\n    }\n\n    handleChange(changedValue, changedStateIdentifier) {\n        const currentValues = { ...this.state[changedStateIdentifier] };\n        currentValues.value = changedValue;\n        this.setState({ [changedStateIdentifier]: currentValues });\n        console.log(`State ${changedStateIdentifier} changed value to ${changedValue}.`);\n    }\n\n    render() {\n        const visualizationProps = constructVisualizationProps(this.state);\n        return (\n            <React.Fragment>\n                <form>\n                    {Object.keys(this.state).map(stateIdentifier => (\n                        <InputFormElement\n                            key={stateIdentifier}\n                            label={identifierToLabel[stateIdentifier]}\n                            value={this.state[stateIdentifier].value}\n                            type={this.state[stateIdentifier].type}\n                            onValueChange={this.handleChange}\n                            stateIdentifier={stateIdentifier}\n                            transformFunction={this.state[stateIdentifier].transformFunction}\n                        />\n                    ))}\n                </form>\n                <Visualization {...visualizationProps} />\n            </React.Fragment>\n        );\n    }\n}\n\nclass InputFormElement extends React.Component {\n    constructor(props) {\n        super(props);\n        this.handleChange = this.handleChange.bind(this);\n    }\n\n    handleChange(e) {\n        this.props.onValueChange(this.props.transformFunction(e, this), this.props.stateIdentifier);\n    }\n\n    render() {\n        return (\n            <label>\n                {this.props.label}\n                <input type={this.props.type} value={this.props.value} onChange={this.handleChange} />\n            </label>\n        );\n    }\n}\n\nexport default InputForm;\n","import InputForm from './components/InputForm';\n\nfunction App() {\n    return (\n        <div className=\"Input\">\n            <InputForm />\n        </div>\n    );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './scss/main.scss';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n    <React.StrictMode>\n        <App />\n    </React.StrictMode>,\n    document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}