{"version":3,"sources":["helpers/utils.js","model/ForecastModel.js","model/InvestmentModel.js","renderer/LineChartd3.js","components/InputForm.js","App.js","reportWebVitals.js","index.js"],"names":["timeDiffIgnoreDivisor","numberOfMonthsOfAYear","isFirstMonthOfAYear","date","getMonth","loadHistoricalETFData","etfIdentifier","apiKey","a","d3","entry","Date","timestamp","toString","dividend","parseFloat","course","historicalData","sort","b","etfHistoricalToCourseForecastArray","map","dateToTimestamp","etfHistoricalToDividendForecastArray","currentYear","getFullYear","dividendForecastArray","forEach","length","push","Math","floor","getTime","HistoricalDataNotPresentException","this","message","name","ForecastModelSingleton","coursePredictors","dividendPredictors","courseForecastArray","maxTimestampBeforeCoursePredictorRepetition","_calculateMaxTimestampBeforePredictorRepetition","maxYearBeforeDividendPredictorRepetition","history","forecastArray","lastTimestampToIncludeInPrediction","abs","backCastTimeFactor","backCastTimestampConstant","filteredForecastArray","filter","regression","linear","order","precision","year","lastYearToIncludeInPrediction","_courseDateToPredictorTimestampAndDateTimestamp","predictorTimestamp","_createCoursePredictorIfNotPresent","predict","predictorYear","_dividendYearToPredictorYear","_createDividendPredictorIfNotPresent","max","backCastTimeConstant","backCastTimeDate","setMonth","instance","getInstance","firstTimestamp","lastTimestamp","corporateTaxRatio","getNextMonthDate","newDate","calculateDividend","isLastMonthOfAYear","predictDividend","calculateCosts","amount","costConfiguration","costs","percentageCosts","fixedCosts","amountWithoutCosts","subtractTaxFreeGain","taxAmount","taxFreeAmount","getTotalShareValue","investmentStep","totalShares","sharePrizes","getNewShareValue","newShares","addAccumulationMonth","investmentSteps","investment","etfToRatio","configOptions","forecast","prevInvestmentStep","newInvestmentStep","dividendNewShares","dividendTotalShares","totalCosts","totalInvestedMoney","totalTaxes","totalPayout","newPayout","costConfig","investmentOfEtfWithoutCosts","etfSharePrize","predictCourse","dividendPayoutMoneyPerShare","newSharesByDividend","leftoverTaxFreeAmount","value","min","summedTaxes","decemberInvestmentStep","firstInvestmentStepOfThisYear","accumulatedBasicProfit","i","profitOverAllTime","profitOfPreviousYears","amountToApplyTaxes","calculateTaxes","newTaxes","newLeftoverTaxFreeAmount","addPayoutMonth","sellingAmount","leftoverAlreadyPaidTaxes","payoutStats","taxes","investmentStepsIdx","amountToSell","amountAlreadySold","costsToPay","alreadyPaidCosts","payoutInvestmentStepIdxForFIFO","currentSharesLeft","alreadySoldShares","leftoverAmountToSell","currentInvestmentStepForFIFO","currentValueOfShares","amountToSellWithCosts","amountOfSharesToSell","amountToSellWithoutCosts","initialValueOfShares","amountToPayTaxes","taxesToPay","payoutAmount","amountOfDividendSharesLeft","amountOfDividendSharesSold","generateEmptyInvestmentStep","emptyInvestmentStep","InvestmentModel","startCapital","monthlyInvestment","monthlyPayout","savingPhaseLength","age","expectationOfLife","_calculateTimestampsForModel","_calculateModel","lifeExpectation","fadeOutYears","yearsLeft","now","beginningDate","endSavingPhaseDate","setFullYear","endDate","calculateForecastInterval","startDate","savingDates","currentDate","payoutDates","slice","savingDate","payoutDate","LineChart3D","renderDivRef","innerHTML","svg","append","attr","width","height","dataToIndex","inflation","currentIdx","capitalIdentifier","dividendIdentifier","lineData","heightOffset","totalShareValue","totalDividendShareValue","cssClass","minVal","e","maxVal","yScale","domain","range","dateExtent","d","xScale","style","call","tickFormat","toLocaleString","datum","x","y","STARTING_CAPITAL_IDENTIFIER","MONTHLY_INVESTMENT_IDENTIFIER","TRANSACTION_COSTS_IDENTIFIER","TRANSACTION_COSTS_TYPE_IDENTIFIER","SAVING_PHASE_IDENTIFIER","AGE_IDENTIFIER","TAX_FREE_AMOUNT_IDENTIFIER","MONTHLY_PAYOUT_IDENTIFIER","LIFE_EXPECTATION","identifierToLabel","transformInputToInt","caller","intVal","parseInt","target","isNaN","transformInputToFloat","transformCheckboxInput","props","loadHistoricData","configure","loadAndCacheHistoricalETFData","console","log","InputForm","state","type","transformFunction","ref","React","createRef","handleChange","bind","changedValue","changedStateIdentifier","currentValues","setState","IBM","render","getVisualizationModel","current","Fragment","Object","keys","stateIdentifier","label","onValueChange","Component","InputFormElement","onChange","App","className","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.f337e43d.chunk.js","sourcesContent":["import * as d3 from 'd3';\n\n// Ignore milliseconds, seconds, minutes.\nconst timeDiffIgnoreDivisor = 1000 * 60 * 60 * 24;\n\nexport const timestampIndexOfForecastArray = 0;\nexport const courseIndexOfForecastArray = 1;\nexport const numberOfMonthsOfAYear = 12;\nexport const inflationRate = 0.01;\n\nexport function isLastMonthOfAYear(date) {\n    return date.getMonth() === numberOfMonthsOfAYear - 1;\n}\n\nexport function clamp(value, min, max) {\n    return Math.max(min, Math.min(value, max));\n}\n\nexport function isFirstMonthOfAYear(date) {\n    return date.getMonth() === 0;\n}\n\nexport async function loadHistoricalETFData(etfIdentifier, apiKey) {\n    const historicalData = await d3.csv(\n        `https://www.alphavantage.co/query?function=TIME_SERIES_MONTHLY_ADJUSTED&symbol=${etfIdentifier}&apikey=${apiKey}&datatype=csv`,\n        entry => {\n            return {\n                date: new Date(entry.timestamp.toString()),\n                dividend: parseFloat(entry['dividend amount']),\n                course: parseFloat(entry['adjusted close']),\n            };\n        }\n    );\n    historicalData.sort((a, b) => a.date - b.date);\n    return historicalData;\n}\n\nexport function etfHistoricalToCourseForecastArray(historicalData) {\n    return historicalData.map(entry => [dateToTimestamp(entry.date), entry.course]);\n}\n\n// Requires sorted historical data. Note it is sorted by default. Do not change the order.\nexport function etfHistoricalToDividendForecastArray(historicalData) {\n    let currentYear = historicalData[0].date.getFullYear();\n    const dividendForecastArray = [[currentYear, 0]];\n    historicalData.forEach(entry => {\n        if (entry.date.getFullYear() === currentYear) {\n            dividendForecastArray[dividendForecastArray.length - 1][courseIndexOfForecastArray] += entry.dividend;\n        } else {\n            currentYear = entry.date.getFullYear();\n            dividendForecastArray.push([currentYear, entry.dividend]);\n        }\n    });\n    dividendForecastArray.sort((a, b) => a[timestampIndexOfForecastArray] - b[timestampIndexOfForecastArray]);\n    return dividendForecastArray;\n}\n\nexport function dateToTimestamp(date) {\n    return Math.floor(date.getTime() / timeDiffIgnoreDivisor);\n}\n\nexport function timestampToDate(timestamp) {\n    return new Date(timestamp * timeDiffIgnoreDivisor);\n}\n\nexport function HistoricalDataNotPresentException(etfIdentifier) {\n    this.message = `First call loadHistoricalDataIfNotPresent() before predicting: ${etfIdentifier}`;\n    this.name = 'HistoricalDataNotPresentException';\n}\n","import regression from 'regression';\nimport {\n    dateToTimestamp,\n    etfHistoricalToCourseForecastArray,\n    etfHistoricalToDividendForecastArray,\n    loadHistoricalETFData,\n    timestampIndexOfForecastArray,\n    courseIndexOfForecastArray,\n    HistoricalDataNotPresentException,\n} from '../helpers/utils';\n\n// USAGE: first call configure to set required static vars. Then the singleton can be accessed via getInstance. Never call the Constructor on your own.\n// Always call loadAndCacheHistoricalETFData of an etf before calling predict on that etf.\nexport class ForecastModelSingleton {\n    static instance = null;\n    static apiKey = null;\n    static backCastTimeConstant = null;\n    static backCastTimeFactor = null;\n\n    // DO NOT CALL. USE getInstance()\n    constructor() {\n        this.historicalData = {};\n        this.coursePredictors = {};\n        this.dividendPredictors = {};\n    }\n\n    static configure(apiKey, backCastTimeFactor = 2, backCastTimeConstant = 7) {\n        ForecastModelSingleton.apiKey = apiKey;\n        ForecastModelSingleton.backCastTimeFactor = backCastTimeFactor;\n\n        const backCastTimeDate = new Date(0);\n        backCastTimeDate.setMonth(backCastTimeConstant);\n        ForecastModelSingleton.backCastTimestampConstant = dateToTimestamp(backCastTimeDate);\n\n        // reset predictors if present.\n        if (ForecastModelSingleton.instance != null) {\n            const instance = ForecastModelSingleton.getInstance();\n            for (const etfIdentifier in instance.coursePredictors) {\n                instance.coursePredictors[etfIdentifier] = {\n                    maxTimestampBeforeCoursePredictorRepetition: ForecastModelSingleton._calculateMaxTimestampBeforePredictorRepetition(\n                        instance.historicalData[etfIdentifier].courseForecastArray\n                    ),\n                };\n            }\n            for (const etfIdentifier in instance.dividendPredictors) {\n                instance.dividendPredictors[etfIdentifier] = {\n                    maxYearBeforeDividendPredictorRepetition: ForecastModelSingleton._calculateMaxTimestampBeforePredictorRepetition(\n                        instance.historicalData[etfIdentifier].dividendForecastArray\n                    ),\n                };\n            }\n        }\n    }\n\n    static getInstance() {\n        if (ForecastModelSingleton.instance == null) {\n            ForecastModelSingleton.instance = new ForecastModelSingleton();\n        }\n        return ForecastModelSingleton.instance;\n    }\n\n    static _calculateMaxTimestampBeforePredictorRepetition(forecastArray) {\n        const firstTimestamp = forecastArray[0][timestampIndexOfForecastArray];\n        const lastTimestamp = forecastArray[forecastArray.length - 1][timestampIndexOfForecastArray];\n        return lastTimestamp + (lastTimestamp - firstTimestamp) / ForecastModelSingleton.backCastTimeFactor;\n    }\n\n    async loadAndCacheHistoricalETFData(etfIdentifier) {\n        if (etfIdentifier in this.historicalData) {\n            return;\n        }\n        const historicalData = await loadHistoricalETFData(etfIdentifier);\n\n        const courseForecastArray = etfHistoricalToCourseForecastArray(historicalData);\n        const maxTimestampBeforeCoursePredictorRepetition = ForecastModelSingleton._calculateMaxTimestampBeforePredictorRepetition(\n            courseForecastArray\n        );\n\n        const dividendForecastArray = etfHistoricalToDividendForecastArray(historicalData);\n        const maxYearBeforeDividendPredictorRepetition = ForecastModelSingleton._calculateMaxTimestampBeforePredictorRepetition(\n            dividendForecastArray\n        );\n\n        this.historicalData[etfIdentifier] = {\n            history: historicalData,\n            courseForecastArray: courseForecastArray,\n            dividendForecastArray: dividendForecastArray,\n        };\n        this.coursePredictors[etfIdentifier] = {\n            maxTimestampBeforeCoursePredictorRepetition: maxTimestampBeforeCoursePredictorRepetition,\n        };\n        this.dividendPredictors[etfIdentifier] = {\n            maxYearBeforeDividendPredictorRepetition: maxYearBeforeDividendPredictorRepetition,\n        };\n    }\n\n    _createCoursePredictorIfNotPresent(etfIdentifier, timestamp) {\n        // Skip if already exists.\n        if (timestamp in this.coursePredictors[etfIdentifier]) {\n            return;\n        }\n        const forecastArray = this.historicalData[etfIdentifier].courseForecastArray;\n        const lastTimestampToIncludeInPrediction =\n            forecastArray[forecastArray.length - 1][timestampIndexOfForecastArray] -\n            Math.abs(forecastArray[forecastArray.length - 1][timestampIndexOfForecastArray] - timestamp) *\n                ForecastModelSingleton.backCastTimeFactor -\n            ForecastModelSingleton.backCastTimestampConstant;\n        const filteredForecastArray = forecastArray.filter(\n            entry => entry[timestampIndexOfForecastArray] >= lastTimestampToIncludeInPrediction\n        );\n        this.coursePredictors[etfIdentifier][timestamp] = regression.linear(filteredForecastArray, {\n            order: 2,\n            precision: 20,\n        });\n    }\n\n    _courseDateToPredictorTimestampAndDateTimestamp(date, etfIdentifier) {\n        const timestamp = dateToTimestamp(date);\n        return [\n            timestamp > this.coursePredictors[etfIdentifier].maxTimestampBeforeCoursePredictorRepetition\n                ? this.coursePredictors[etfIdentifier].maxTimestampBeforeCoursePredictorRepetition\n                : timestamp,\n            timestamp,\n        ];\n    }\n\n    _createDividendPredictorIfNotPresent(etfIdentifier, year) {\n        // Skip if already exists.\n        if (year in this.dividendPredictors[etfIdentifier]) {\n            return;\n        }\n        const forecastArray = this.historicalData[etfIdentifier].dividendForecastArray;\n        const lastYearToIncludeInPrediction =\n            forecastArray[forecastArray.length - 1][timestampIndexOfForecastArray] -\n            Math.abs(forecastArray[forecastArray.length - 1][timestampIndexOfForecastArray] - year) *\n                ForecastModelSingleton.backCastTimeFactor -\n            ForecastModelSingleton.backCastTimestampConstant;\n        const filteredForecastArray = forecastArray.filter(\n            entry => entry[timestampIndexOfForecastArray] >= lastYearToIncludeInPrediction\n        );\n        this.dividendPredictors[etfIdentifier][year] = regression.linear(filteredForecastArray, {\n            order: 2,\n            precision: 20,\n        });\n    }\n\n    _dividendYearToPredictorYear(etfIdentifier, year) {\n        return this.dividendPredictors[etfIdentifier].maxYearBeforeDividendPredictorRepetition < year\n            ? this.dividendPredictors[etfIdentifier].maxYearBeforeDividendPredictorRepetition\n            : year;\n    }\n\n    predictCourse(etfIdentifier, date) {\n        if (!(etfIdentifier in this.coursePredictors)) {\n            throw new HistoricalDataNotPresentException(etfIdentifier);\n        }\n        const [predictorTimestamp, timestamp] = this._courseDateToPredictorTimestampAndDateTimestamp(\n            date,\n            etfIdentifier\n        );\n        this._createCoursePredictorIfNotPresent(etfIdentifier, predictorTimestamp);\n        return this.coursePredictors[etfIdentifier][predictorTimestamp].predict(timestamp)[courseIndexOfForecastArray];\n    }\n\n    predictDividend(etfIdentifier, year) {\n        if (!(etfIdentifier in this.dividendPredictors)) {\n            throw new HistoricalDataNotPresentException(etfIdentifier);\n        }\n        const predictorYear = this._dividendYearToPredictorYear(etfIdentifier, year);\n        this._createDividendPredictorIfNotPresent(etfIdentifier, predictorYear);\n        return Math.max(\n            0,\n            this.dividendPredictors[etfIdentifier][predictorYear].predict(year)[courseIndexOfForecastArray]\n        );\n    }\n}\n\nexport default ForecastModelSingleton;\n","import ForecastModelSingleton from './ForecastModel';\nimport { numberOfMonthsOfAYear, isLastMonthOfAYear, clamp, isFirstMonthOfAYear } from '../helpers/utils';\n\nconst basicRateOfInterest = 0.007;\nconst partialExemption = 0.7;\nconst corporateTaxRatio = 0.26375;\n\nfunction getNextMonthDate(date) {\n    const newDate = new Date(date);\n    newDate.setMonth(date.getMonth() + 1);\n    return newDate;\n}\n\nfunction calculateDividend(etfIdentifier, date) {\n    if (!isLastMonthOfAYear(date)) {\n        return 0;\n    } else {\n        return ForecastModelSingleton.getInstance().predictDividend(etfIdentifier, date.getFullYear());\n    }\n}\n\nfunction calculateCosts(amount, costConfiguration) {\n    let costs = amount * costConfiguration.percentageCosts + costConfiguration.fixedCosts;\n    const amountWithoutCosts = Math.max(amount - costs, 0);\n    costs = amount - amountWithoutCosts;\n    return [amountWithoutCosts, costs];\n}\n\nfunction subtractTaxFreeGain(taxAmount, taxFreeAmount) {\n    const leftoverTaxes = Math.max(0, taxAmount - taxFreeAmount);\n    const leftoverTaxFreeAmount = Math.max(0, taxFreeAmount - taxAmount);\n    return [leftoverTaxes, leftoverTaxFreeAmount];\n}\n\nexport function getTotalShareValue(etfIdentifier, investmentStep) {\n    return investmentStep.totalShares[etfIdentifier] * investmentStep.sharePrizes[etfIdentifier];\n}\n\nfunction getNewShareValue(etfIdentifier, investmentStep) {\n    return investmentStep.newShares[etfIdentifier] * investmentStep.sharePrizes[etfIdentifier];\n}\n\nfunction calculateForecastInterval(age, lifeExpectation, savingPhaseLength, fadeOutYears = 10) {\n    const yearsLeft = lifeExpectation - age;\n    const now = new Date();\n    const beginningDate = new Date(now.getFullYear(), now.getMonth() + 1);\n    // start next month.\n    const endSavingPhaseDate = new Date(beginningDate);\n    endSavingPhaseDate.setFullYear(beginningDate.getFullYear() + savingPhaseLength);\n    const endDate = new Date(beginningDate);\n    endDate.setFullYear(beginningDate.getFullYear() + yearsLeft + fadeOutYears);\n    return [beginningDate, endSavingPhaseDate, endDate];\n}\n\nfunction calculateTaxes(investmentSteps, date, leftoverTaxFreeAmount, etfToRatio) {\n    if (!isFirstMonthOfAYear(date) || investmentSteps.length < 2) {\n        return [0, leftoverTaxFreeAmount];\n    }\n    let summedTaxes = 0;\n    const decemberInvestmentStep = investmentSteps[investmentSteps.length - 1];\n    // Use the second investment step if there are not enough meaning the investing started this year after january.\n    // The second is the true first investment step the first is a dummy.\n    const firstInvestmentStepOfThisYear =\n        investmentSteps.length - numberOfMonthsOfAYear > 1\n            ? investmentSteps[investmentSteps.length - numberOfMonthsOfAYear]\n            : investmentSteps[1];\n    for (const etfIdentifier in etfToRatio) {\n        let accumulatedBasicProfit = 0;\n        // Sum up all new investments from february to december.\n        for (let i = 1; i < numberOfMonthsOfAYear && investmentSteps.length - i > 0; i++) {\n            const currentInvestmentStep = investmentSteps[investmentSteps.length - i];\n            accumulatedBasicProfit +=\n                (getNewShareValue(etfIdentifier, currentInvestmentStep) * i) / numberOfMonthsOfAYear;\n        }\n        // Sum up total Investment of the first date of this year.\n        accumulatedBasicProfit +=\n            (getTotalShareValue(etfIdentifier, firstInvestmentStepOfThisYear) *\n                (numberOfMonthsOfAYear - firstInvestmentStepOfThisYear.date.getMonth())) /\n            numberOfMonthsOfAYear;\n        accumulatedBasicProfit *= 0.7 * basicRateOfInterest;\n        const currentShareValues = getTotalShareValue(etfIdentifier, decemberInvestmentStep);\n        // Calculate profit of last year.\n        const profitOverAllTime = currentShareValues - decemberInvestmentStep.totalInvestedMoney[etfIdentifier];\n        let profitOfPreviousYears = 0;\n        if (investmentSteps.length > numberOfMonthsOfAYear) {\n            profitOfPreviousYears = Math.max(\n                0,\n                getTotalShareValue(etfIdentifier, investmentSteps[investmentSteps.length - 1 - numberOfMonthsOfAYear]) -\n                    investmentSteps[investmentSteps.length - 1 - numberOfMonthsOfAYear].totalInvestedMoney[\n                        etfIdentifier\n                    ]\n            );\n        }\n\n        const profitOfThisYear = profitOverAllTime - profitOfPreviousYears;\n        let amountToApplyTaxes = clamp(profitOfThisYear, 0, accumulatedBasicProfit);\n        [amountToApplyTaxes, leftoverTaxFreeAmount] = subtractTaxFreeGain(amountToApplyTaxes, leftoverTaxFreeAmount);\n        summedTaxes += amountToApplyTaxes * partialExemption * corporateTaxRatio;\n    }\n    return [summedTaxes, leftoverTaxFreeAmount];\n}\n\nexport function addAccumulationMonth(investmentSteps, investment, date, etfToRatio, configOptions) {\n    const forecast = ForecastModelSingleton.getInstance();\n    let costs = 0;\n    const prevInvestmentStep = investmentSteps[investmentSteps.length - 1];\n    const newInvestmentStep = {\n        date: date,\n        newShares: {},\n        totalShares: { ...prevInvestmentStep.totalShares },\n        dividendNewShares: {},\n        dividendTotalShares: { ...prevInvestmentStep.dividendTotalShares },\n        totalCosts: prevInvestmentStep.totalCosts,\n        sharePrizes: {},\n        totalInvestedMoney: { ...prevInvestmentStep.totalInvestedMoney },\n        totalTaxes: prevInvestmentStep.totalTaxes,\n        totalPayout: { ...prevInvestmentStep.totalPayout },\n        newPayout: {},\n    };\n    for (const etfIdentifier in etfToRatio) {\n        const investmentOfEtfWithCosts = etfToRatio[etfIdentifier] * investment;\n        const [investmentOfEtfWithoutCosts, newCosts] = calculateCosts(\n            investmentOfEtfWithCosts,\n            configOptions.costConfig\n        );\n        costs += newCosts;\n        newInvestmentStep.totalInvestedMoney[etfIdentifier] += investmentOfEtfWithoutCosts;\n\n        const etfSharePrize = forecast.predictCourse(etfIdentifier, date);\n        const newShares = investmentOfEtfWithoutCosts / etfSharePrize;\n        newInvestmentStep.sharePrizes[etfIdentifier] = etfSharePrize;\n        newInvestmentStep.newShares[etfIdentifier] = newShares;\n\n        const dividendPayoutMoneyPerShare = calculateDividend(etfIdentifier, date);\n        const dividendPayoutMoney = newInvestmentStep.totalShares[etfIdentifier] * dividendPayoutMoneyPerShare;\n        const newSharesByDividend = dividendPayoutMoney / etfSharePrize;\n        newInvestmentStep.newShares[etfIdentifier] += newSharesByDividend;\n        newInvestmentStep.dividendNewShares[etfIdentifier] = newSharesByDividend;\n        newInvestmentStep.dividendTotalShares[etfIdentifier] += newSharesByDividend;\n\n        newInvestmentStep.totalShares[etfIdentifier] += newInvestmentStep.newShares[etfIdentifier];\n        newInvestmentStep.newPayout[etfIdentifier] = 0;\n    }\n    newInvestmentStep.totalCosts += costs;\n    const [newTaxes, newLeftoverTaxFreeAmount] = calculateTaxes(\n        investmentSteps,\n        date,\n        configOptions.taxFreeAmount,\n        etfToRatio\n    );\n    newInvestmentStep.totalTaxes += newTaxes;\n    investmentSteps.push(newInvestmentStep);\n\n    return newLeftoverTaxFreeAmount;\n}\n\nfunction addPayoutMonth(\n    investmentSteps,\n    sellingAmount,\n    etfToRatio,\n    date,\n    configOptions,\n    leftoverAlreadyPaidTaxes,\n    leftoverTaxFreeAmount,\n    payoutStats\n) {\n    if (isFirstMonthOfAYear(date)) {\n        leftoverTaxFreeAmount = configOptions.taxFreeAmount;\n    }\n    const forecast = ForecastModelSingleton.getInstance();\n    let costs = 0;\n    let taxes = 0;\n    const prevInvestmentStep = investmentSteps[investmentSteps.length - 1];\n    const newInvestmentStep = {\n        date: date,\n        newShares: {},\n        totalShares: { ...prevInvestmentStep.totalShares },\n        dividendNewShares: {},\n        dividendTotalShares: { ...prevInvestmentStep.dividendTotalShares },\n        totalCosts: prevInvestmentStep.totalCosts,\n        sharePrizes: {},\n        totalInvestedMoney: { ...prevInvestmentStep.totalInvestedMoney },\n        totalTaxes: prevInvestmentStep.totalTaxes,\n        totalPayout: { ...prevInvestmentStep.totalPayout },\n        newPayout: {},\n    };\n    for (const etfIdentifier in etfToRatio) {\n        const etfSharePrize = forecast.predictCourse(etfIdentifier, date);\n        newInvestmentStep.sharePrizes[etfIdentifier] = etfSharePrize;\n        newInvestmentStep.newPayout[etfIdentifier] = 0;\n        // Skip payout if there are no shares left to sell.\n        if (payoutStats[etfIdentifier].investmentStepsIdx < investmentSteps.length) {\n            // Handle payout.\n            const amountToSell = sellingAmount * etfToRatio[etfIdentifier];\n            let amountAlreadySold = 0;\n            const costsToPay = calculateCosts(amountToSell, configOptions.costConfig)[1];\n            let alreadyPaidCosts = 0;\n            let payoutInvestmentStepIdxForFIFO = payoutStats[etfIdentifier].investmentStepsIdx;\n            let currentSharesLeft =\n                investmentSteps[payoutInvestmentStepIdxForFIFO].newShares[etfIdentifier] -\n                payoutStats[etfIdentifier].alreadySoldShares;\n            for (; payoutInvestmentStepIdxForFIFO < investmentSteps.length; payoutInvestmentStepIdxForFIFO++) {\n                const leftoverAmountToSell = amountToSell - amountAlreadySold;\n                const currentInvestmentStepForFIFO = investmentSteps[payoutInvestmentStepIdxForFIFO];\n\n                const currentValueOfShares =\n                    etfSharePrize *\n                    (payoutInvestmentStepIdxForFIFO === payoutStats[etfIdentifier].investmentStepsIdx\n                        ? currentInvestmentStepForFIFO.newShares[etfIdentifier] -\n                          payoutStats[etfIdentifier].alreadySoldShares\n                        : currentInvestmentStepForFIFO.newShares[etfIdentifier]);\n                const amountToSellWithCosts = Math.min(currentValueOfShares, leftoverAmountToSell);\n                const amountOfSharesToSell = amountToSellWithCosts / etfSharePrize;\n                currentSharesLeft = currentInvestmentStepForFIFO.newShares[etfIdentifier] - amountOfSharesToSell;\n                currentSharesLeft -=\n                    payoutInvestmentStepIdxForFIFO === payoutStats[etfIdentifier].investmentStepsIdx\n                        ? payoutStats[etfIdentifier].alreadySoldShares\n                        : 0;\n\n                const amountToSellWithoutCosts = Math.max(0, amountToSellWithCosts - (costsToPay - alreadyPaidCosts));\n                alreadyPaidCosts += Math.max(0, amountToSellWithCosts - amountToSellWithoutCosts);\n\n                const initialValueOfShares =\n                    amountOfSharesToSell * currentInvestmentStepForFIFO.sharePrizes[etfIdentifier];\n                let amountToPayTaxes = Math.max(0, amountToSellWithoutCosts - initialValueOfShares);\n\n                [amountToPayTaxes, leftoverTaxFreeAmount] = subtractTaxFreeGain(\n                    amountToPayTaxes,\n                    leftoverTaxFreeAmount\n                );\n                let taxesToPay = amountToPayTaxes * partialExemption * corporateTaxRatio;\n                [taxesToPay, leftoverAlreadyPaidTaxes] = subtractTaxFreeGain(taxesToPay, leftoverAlreadyPaidTaxes);\n                taxes += taxesToPay;\n                const payoutAmount = amountToSellWithoutCosts - taxesToPay;\n\n                newInvestmentStep.newPayout[etfIdentifier] += payoutAmount;\n                newInvestmentStep.totalPayout[etfIdentifier] += payoutAmount;\n\n                newInvestmentStep.totalShares[etfIdentifier] -= amountOfSharesToSell;\n                amountAlreadySold += amountToSellWithCosts;\n\n                // Handle the decrease of the dividendShares.\n                let amountOfDividendSharesLeft = 0;\n                if (payoutInvestmentStepIdxForFIFO === payoutStats[etfIdentifier].investmentStepsIdx) {\n                    amountOfDividendSharesLeft = Math.max(\n                        0,\n                        currentInvestmentStepForFIFO.dividendNewShares[etfIdentifier] -\n                            payoutStats[etfIdentifier].alreadySoldShares\n                    );\n                } else {\n                    amountOfDividendSharesLeft = currentInvestmentStepForFIFO.dividendNewShares[etfIdentifier];\n                }\n                const amountOfDividendSharesSold = Math.min(amountOfDividendSharesLeft, amountOfSharesToSell);\n                newInvestmentStep.dividendTotalShares[etfIdentifier] -= amountOfDividendSharesSold;\n\n                // Use break in order to not change the value of payoutInvestmentStepIdxForFIFO.\n                if (amountAlreadySold >= amountToSell) {\n                    break;\n                }\n            }\n            costs += alreadyPaidCosts;\n            // Handle update payoutStats.\n            payoutStats[etfIdentifier].investmentStepsIdx = payoutInvestmentStepIdxForFIFO;\n            payoutStats[etfIdentifier].investmentStepsIdx += currentSharesLeft === 0 ? 1 : 0;\n\n            payoutStats[etfIdentifier].alreadySoldShares =\n                payoutInvestmentStepIdxForFIFO < investmentSteps.length\n                    ? investmentSteps[payoutInvestmentStepIdxForFIFO].newShares[etfIdentifier] - currentSharesLeft\n                    : 0;\n        }\n\n        // Handle dividend.\n        const dividendPayoutMoney =\n            newInvestmentStep.totalShares[etfIdentifier] * calculateDividend(etfIdentifier, date);\n        const newSharesByDividend = dividendPayoutMoney / etfSharePrize;\n        newInvestmentStep.newShares[etfIdentifier] = newSharesByDividend;\n        newInvestmentStep.totalShares[etfIdentifier] += newSharesByDividend;\n        newInvestmentStep.dividendNewShares[etfIdentifier] = newSharesByDividend;\n        newInvestmentStep.dividendTotalShares[etfIdentifier] += newSharesByDividend;\n    }\n\n    newInvestmentStep.totalCosts += costs;\n    newInvestmentStep.totalTaxes += taxes;\n    investmentSteps.push(newInvestmentStep);\n    return [leftoverAlreadyPaidTaxes, leftoverTaxFreeAmount];\n}\n\nfunction generateEmptyInvestmentStep(etfToRatio, date) {\n    const forecast = ForecastModelSingleton.getInstance();\n    const emptyInvestmentStep = {\n        date: date,\n        totalCosts: 0,\n        totalTaxes: 0,\n        newShares: {},\n        totalShares: {},\n        dividendNewShares: {},\n        dividendTotalShares: {},\n        totalInvestedMoney: {},\n        totalPayout: {},\n        newPayout: {},\n        sharePrizes: {},\n    };\n    for (const etfIdentifier in etfToRatio) {\n        emptyInvestmentStep.newShares[etfIdentifier] = 0;\n        emptyInvestmentStep.totalShares[etfIdentifier] = 0;\n        emptyInvestmentStep.dividendNewShares[etfIdentifier] = 0;\n        emptyInvestmentStep.dividendTotalShares[etfIdentifier] = 0;\n        emptyInvestmentStep.totalInvestedMoney[etfIdentifier] = 0;\n        emptyInvestmentStep.totalPayout[etfIdentifier] = 0;\n        emptyInvestmentStep.newPayout[etfIdentifier] = 0;\n        emptyInvestmentStep.sharePrizes[etfIdentifier] = forecast.predictCourse(etfIdentifier, date);\n    }\n    return emptyInvestmentStep;\n}\n\nexport class InvestmentModel {\n    constructor(\n        startCapital,\n        monthlyInvestment,\n        monthlyPayout,\n        savingPhaseLength,\n        etfToRatio,\n        configOptions,\n        age,\n        expectationOfLife\n    ) {\n        this.startCapital = startCapital;\n        this.monthlyInvestment = monthlyInvestment;\n        this.monthlyPayout = monthlyPayout;\n        this.savingPhaseLength = savingPhaseLength;\n        this.etfToRatio = etfToRatio;\n        this.configOptions = configOptions;\n        this.expectationOfLife = expectationOfLife;\n        this.age = age;\n        this._calculateTimestampsForModel();\n        this._calculateModel();\n    }\n\n    _calculateTimestampsForModel() {\n        const [startDate, endSavingPhaseDate, endDate] = calculateForecastInterval(\n            this.age,\n            this.expectationOfLife,\n            this.savingPhaseLength\n        );\n        const savingDates = [];\n        for (\n            let currentDate = startDate;\n            currentDate < endSavingPhaseDate;\n            currentDate = getNextMonthDate(currentDate)\n        ) {\n            savingDates.push(currentDate);\n        }\n        this.savingDates = savingDates;\n        const payoutDates = [];\n        for (let currentDate = endSavingPhaseDate; currentDate < endDate; currentDate = getNextMonthDate(currentDate)) {\n            payoutDates.push(currentDate);\n        }\n        this.payoutDates = payoutDates;\n    }\n\n    _calculateModel() {\n        let investmentSteps = [generateEmptyInvestmentStep(this.etfToRatio, this.savingDates[0])];\n        let leftoverTaxFreeAmount = addAccumulationMonth(\n            investmentSteps,\n            this.monthlyInvestment + this.startCapital,\n            this.savingDates[0],\n            this.etfToRatio,\n            this.configOptions\n        );\n        for (const savingDate of this.savingDates.slice(1)) {\n            leftoverTaxFreeAmount = addAccumulationMonth(\n                investmentSteps,\n                this.monthlyInvestment,\n                savingDate,\n                this.etfToRatio,\n                this.configOptions\n            );\n        }\n        // Discard the empty investment step.\n        investmentSteps = investmentSteps.slice(1);\n\n        let leftoverAlreadyPaidTaxes = investmentSteps[investmentSteps.length - 1].totalTaxes;\n        const payoutStats = {};\n        for (const etfIdentifier in this.etfToRatio) {\n            payoutStats[etfIdentifier] = { investmentStepsIdx: 0, alreadySoldShares: 0 };\n        }\n        for (const payoutDate of this.payoutDates) {\n            [leftoverAlreadyPaidTaxes, leftoverTaxFreeAmount] = addPayoutMonth(\n                investmentSteps,\n                this.monthlyPayout,\n                this.etfToRatio,\n                payoutDate,\n                this.configOptions,\n                leftoverAlreadyPaidTaxes,\n                leftoverTaxFreeAmount,\n                payoutStats\n            );\n        }\n        this.investmentSteps = investmentSteps;\n    }\n}\n","import * as d3 from 'd3';\nimport { getTotalShareValue } from '../model/InvestmentModel';\n\nexport class LineChart3D {\n    render(investmentSteps, renderDivRef) {\n        const svgID = 'firstSVG';\n\n        const marginW = 150,\n            marginH = 40,\n            width = 1000,\n            height = 400;\n\n        const zeroLineStrokeWidth = 3;\n\n        // Reset diagram by deletion.\n        renderDivRef.innerHTML = '';\n\n        const svg = d3\n            .select(renderDivRef)\n            .append('svg')\n            .attr('id', svgID)\n            .attr('height', '100%')\n            .attr('width', '100%')\n            .attr('viewBox', `0 0 ${width + 2 * marginW} ${height + 2 * marginH}`)\n            .append('g')\n            .attr('transform', `translate(${[marginW, marginH]})`);\n\n        // Create line array.\n        const dataToIndex = {\n            costs: 0,\n            taxes: 1,\n            inflation: 2,\n        };\n        let currentIdx = 3;\n        const capitalIdentifier = 'capital';\n        const dividendIdentifier = 'dividend';\n        for (const etfIdentifier in investmentSteps[0].totalShares) {\n            dataToIndex[etfIdentifier + dividendIdentifier] = currentIdx++;\n            dataToIndex[etfIdentifier + capitalIdentifier] = currentIdx++;\n        }\n\n        const lineData = [];\n        for (let i = 0; i < currentIdx; i++) {\n            lineData.push([]);\n        }\n        for (const investmentStep of investmentSteps) {\n            lineData[dataToIndex.costs].push({ value: -investmentStep.totalCosts, date: investmentStep.date });\n            lineData[dataToIndex.taxes].push({\n                value: -investmentStep.totalCosts - investmentStep.totalTaxes,\n                date: investmentStep.date,\n            });\n            lineData[dataToIndex.inflation].push({\n                value: -investmentStep.totalCosts - investmentStep.totalTaxes,\n                date: investmentStep.date,\n            });\n            let heightOffset = 0;\n            for (const etfIdentifier in investmentStep.totalShares) {\n                const totalShareValue = getTotalShareValue(etfIdentifier, investmentStep);\n                const totalDividendShareValue =\n                    investmentStep.dividendTotalShares[etfIdentifier] * investmentStep.sharePrizes[etfIdentifier];\n                lineData[dataToIndex[etfIdentifier + capitalIdentifier]].push({\n                    value: totalShareValue + heightOffset,\n                    date: investmentStep.date,\n                });\n                lineData[dataToIndex[etfIdentifier + dividendIdentifier]].push({\n                    value: totalShareValue - totalDividendShareValue + heightOffset,\n                    date: investmentStep.date,\n                });\n                heightOffset += totalShareValue;\n            }\n        }\n\n        // Append miscellaneous data to array.\n        lineData[dataToIndex.inflation].cssClass = 'inflation';\n        lineData[dataToIndex.taxes].cssClass = 'taxes';\n        lineData[dataToIndex.costs].cssClass = 'costs';\n        for (const etfIdentifier in investmentSteps[0].totalShares) {\n            lineData[dataToIndex[etfIdentifier + dividendIdentifier]].cssClass = `${etfIdentifier}_dividend`;\n            lineData[dataToIndex[etfIdentifier + capitalIdentifier]].cssClass = `${etfIdentifier}_total_amount`;\n        }\n\n        // Create scales.\n        const minVal = d3.min(lineData[dataToIndex.inflation].map(e => e.value));\n        const maxVal = d3.max(lineData[lineData.length - 1].map(e => e.value));\n\n        const yScale = d3.scaleLinear().domain([minVal, maxVal]).range([height, 0]);\n        const dateExtent = d3.extent(lineData[0], d => d.date);\n        const xScale = d3.scaleTime().domain(dateExtent).range([0, width]);\n\n        // Draw axis.\n        svg.append('g')\n            .style('font-size', '20px')\n            .call(d3.axisLeft(yScale).tickFormat(d => `${d.toLocaleString()} EUR`));\n\n        svg.append('g')\n            .style('font-size', '20px')\n            .attr('transform', `translate(0, ${height})`)\n            .call(d3.axisBottom(xScale));\n\n        // Draw zero line.\n        svg.append('g')\n            .append('line')\n            .attr('x1', xScale(dateExtent[0]))\n            .attr('y1', yScale(0))\n            .attr('x2', xScale(dateExtent[1]))\n            .attr('y2', yScale(0))\n            .attr('stroke-width', zeroLineStrokeWidth)\n            .attr('stroke', 'black');\n\n        for (let i = 0; i < lineData.length; i++) {\n            svg.append('path')\n                .datum(lineData[i])\n                .attr('fill', 'none')\n                .attr('class', d => d.cssClass)\n                .attr('stroke-width', 3)\n                .attr(\n                    'd',\n                    d3\n                        .line()\n                        .x(d => xScale(d.date))\n                        .y(d => yScale(d.value))\n                );\n        }\n    }\n}\n\nexport default LineChart3D;\n","import React from 'react';\nimport ForecastModelSingleton from '../model/ForecastModel';\nimport { InvestmentModel } from '../model/InvestmentModel';\nimport LineChart3D from '../renderer/LineChartd3';\n\nconst STARTING_CAPITAL_IDENTIFIER = 'startingCapital';\nconst MONTHLY_INVESTMENT_IDENTIFIER = 'monthlyInvestment';\nconst TRANSACTION_COSTS_IDENTIFIER = 'transactionCosts';\nconst TRANSACTION_COSTS_TYPE_IDENTIFIER = 'transactionCostsType';\nconst SAVING_PHASE_IDENTIFIER = 'savingPhase';\nconst AGE_IDENTIFIER = 'age';\nconst TAX_FREE_AMOUNT_IDENTIFIER = 'taxFreeAmount';\nconst MONTHLY_PAYOUT_IDENTIFIER = 'monthlyPayout';\nconst LIFE_EXPECTATION = 'lifeExpectation';\n\nconst identifierToLabel = {\n    [STARTING_CAPITAL_IDENTIFIER]: 'Starting Capital',\n    [MONTHLY_INVESTMENT_IDENTIFIER]: 'Monthly Investment',\n    [TRANSACTION_COSTS_IDENTIFIER]: 'Transaction Costs',\n    [TRANSACTION_COSTS_TYPE_IDENTIFIER]: 'Fixes Amount ?',\n    [SAVING_PHASE_IDENTIFIER]: 'Saving Phase',\n    [AGE_IDENTIFIER]: 'Your Age',\n    [TAX_FREE_AMOUNT_IDENTIFIER]: 'Tax Free Amount',\n    [MONTHLY_PAYOUT_IDENTIFIER]: 'Monthly Payout',\n    [LIFE_EXPECTATION]: 'Life Expectation',\n};\n\nfunction transformInputToInt(e, caller) {\n    const intVal = parseInt(e.target.value);\n    return isNaN(intVal) ? 0 : intVal;\n}\n\nfunction transformInputToFloat(e, caller) {\n    const intVal = parseFloat(e.target.value);\n    return isNaN(intVal) ? 0 : intVal;\n}\n\nfunction transformCheckboxInput(e, caller) {\n    return !caller.props.value;\n}\n\nfunction generateCostConfig(state) {\n    if (state[TRANSACTION_COSTS_TYPE_IDENTIFIER].value) {\n        return { percentageCosts: 0.0, fixedCosts: state[TRANSACTION_COSTS_IDENTIFIER].value };\n    } else {\n        return { percentageCosts: state[TRANSACTION_COSTS_IDENTIFIER].value, fixedCosts: 0.0 };\n    }\n}\n\nasync function loadHistoricData(){\n    ForecastModelSingleton.configure('demo');\n    const forecast = ForecastModelSingleton.getInstance();\n    await forecast.loadAndCacheHistoricalETFData('IBM');\n    console.log('Finished loading the historic data.');\n}\n\nclass InputForm extends React.Component {\n    constructor(props) {\n        super(props);\n        this.state = {\n            [STARTING_CAPITAL_IDENTIFIER]: { value: 10000, type: 'text', transformFunction: transformInputToInt },\n            [MONTHLY_INVESTMENT_IDENTIFIER]: { value: 100, type: 'text', transformFunction: transformInputToInt },\n            [MONTHLY_PAYOUT_IDENTIFIER]: { value: 1000, type: 'text', transformFunction: transformInputToInt },\n            [TRANSACTION_COSTS_IDENTIFIER]: { value: 0.005, type: 'text', transformFunction: transformInputToFloat },\n            [TRANSACTION_COSTS_TYPE_IDENTIFIER]: {\n                value: false,\n                type: 'checkbox',\n                transformFunction: transformCheckboxInput,\n            },\n            [SAVING_PHASE_IDENTIFIER]: { value: 40, type: 'text', transformFunction: transformInputToInt },\n            [AGE_IDENTIFIER]: { value: 30, type: 'text', transformFunction: transformInputToInt },\n            [TAX_FREE_AMOUNT_IDENTIFIER]: { value: 801, type: 'text', transformFunction: transformInputToInt },\n            [LIFE_EXPECTATION]: { value: 80, type: 'text', transformFunction: transformInputToInt },\n        };\n\n        this.ref = React.createRef();\n        this.handleChange = this.handleChange.bind(this);\n    }\n\n    handleChange(changedValue, changedStateIdentifier) {\n        const currentValues = {...this.state[changedStateIdentifier]};\n        currentValues.value = changedValue;\n        this.setState({[changedStateIdentifier]: currentValues});\n        console.log(`State ${changedStateIdentifier} changed value to ${changedValue}.`);\n    }\n\n    getVisualizationModel() {\n        return new InvestmentModel(\n            this.state[STARTING_CAPITAL_IDENTIFIER].value,\n            this.state[MONTHLY_INVESTMENT_IDENTIFIER].value,\n            this.state[MONTHLY_PAYOUT_IDENTIFIER].value,\n            this.state[SAVING_PHASE_IDENTIFIER].value,\n            { IBM: 1.0 },\n            {\n                taxFreeAmount: this.state[TAX_FREE_AMOUNT_IDENTIFIER].value,\n                costConfig: generateCostConfig(this.state),\n            },\n            this.state[AGE_IDENTIFIER].value,\n            this.state[LIFE_EXPECTATION].value\n        );\n    }\n\n    async componentDidMount() {\n        await loadHistoricData();\n        new LineChart3D().render(this.getVisualizationModel().investmentSteps, this.ref.current);\n    }\n\n    componentDidUpdate() {\n        new LineChart3D().render(this.getVisualizationModel().investmentSteps, this.ref.current);\n    }\n\n    render() {\n        return (\n            <React.Fragment>\n                <form>\n                    {Object.keys(this.state).map(stateIdentifier => (\n                        <InputFormElement\n                            key={stateIdentifier}\n                            label={identifierToLabel[stateIdentifier]}\n                            value={this.state[stateIdentifier].value}\n                            type={this.state[stateIdentifier].type}\n                            onValueChange={this.handleChange}\n                            stateIdentifier={stateIdentifier}\n                            transformFunction={this.state[stateIdentifier].transformFunction}\n                        />\n                    ))}\n                </form>\n                <div ref={this.ref}></div>\n            </React.Fragment>\n        );\n    }\n}\n\nclass InputFormElement extends React.Component {\n    constructor(props) {\n        super(props);\n        this.handleChange = this.handleChange.bind(this);\n    }\n\n    handleChange(e) {\n        this.props.onValueChange(this.props.transformFunction(e, this), this.props.stateIdentifier);\n    }\n\n    render() {\n        return (\n            <label>\n                {this.props.label}\n                <input type={this.props.type} value={this.props.value} onChange={this.handleChange} />\n            </label>\n        );\n    }\n}\n\nexport default InputForm;\n","import './App.css';\nimport InputForm from './components/InputForm';\n\nfunction App() {\n    return (\n        <div className=\"Input\">\n            <InputForm />\n        </div>\n    );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}