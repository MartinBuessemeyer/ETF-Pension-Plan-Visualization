import { ForecastModelSingleton, ETFIdentifier } from './ForecastModel';
import { numberOfMonthsOfAYear, isLastMonthOfAYear, clamp, isFirstMonthOfAYear } from '../helpers/utils';
import cloneDeep from 'lodash.clonedeep';

import { ICostConfiguration, IConfigOptions } from '../components/Visualization';

type ETFShares = { [key in ETFIdentifier]: number };

export type ETFRatio = { [key in ETFIdentifier]?: number };

export type NegativeInvestmentStepIdentifier = 'totalCosts' | 'totalTaxes' | 'inflation';

export interface InvestmentStep {
    date: Date;
    newShares: ETFShares;
    totalShares: ETFShares;
    dividendNewShares: ETFShares;
    dividendTotalShares: ETFShares;
    distributingNewAmount: ETFShares;
    distributingAmountUsableForPayout: ETFShares;
    totalCosts: number;
    sharePrices: ETFShares;
    totalInvestedMoney: ETFShares;
    newInvestedMoney: ETFShares;
    newInvestment: number;
    totalTaxes: number;
    totalPayout: ETFShares;
    newPayout: ETFShares;
    inflation: number;
}

type IPayoutStats = { [key in ETFIdentifier]: IPayoutStat };

interface IPayoutStat {
    investmentStepsIdx: number;
    alreadySoldShares: number;
}

const basicRateOfInterest = 0.007;
const partialExemption = 0.7;
const corporateTaxRatio = 0.26375;
const inflationRate = 0.01;
const defaultDividendAmount = 0.025;

/**
 * Calculates the currency value of all shares of the etf for the given investment step.
 *
 * @param etfIdentifier The concerning etfIdentifier.
 * @param investmentStep The concerning InvestmentStep.
 * @returns The currency value of the total shares of the specified etf.
 */
export function getTotalShareValue(etfIdentifier: ETFIdentifier, investmentStep: InvestmentStep): number {
    return investmentStep.totalShares[etfIdentifier] * investmentStep.sharePrices[etfIdentifier];
}

/**
 * Calculates the currency value of all shares generated by dividends of the etf for the given investment step.
 *
 * @param etfIdentifier The concerning etfIdentifier.
 * @param investmentStep The concerning InvestmentStep.
 * @returns The currency value of the total shares generated by dividends. of the specified etf.
 */
export function getTotalDividendShareValue(etfIdentifier: ETFIdentifier, investmentStep: InvestmentStep): number {
    return investmentStep.dividendTotalShares[etfIdentifier] * investmentStep.sharePrices[etfIdentifier];
}

/**
 * Calculates the currency value of new shares of the etf for the given investment step.
 *
 * @param etfIdentifier The concerning etfIdentifier.
 * @param investmentStep The concerning InvestmentStep.
 * @returns The currency value of the new shares of the specified etf.
 */
function getNewShareValue(etfIdentifier: ETFIdentifier, investmentStep: InvestmentStep): number {
    return investmentStep.newShares[etfIdentifier] * investmentStep.sharePrices[etfIdentifier];
}

/**
 * Calculates the sum of all payout over all used ETFs.
 *
 * @param investmentStep The concerning investmentStep.
 * @returns The sum of all payouts.
 */
export function getSumNewPayout(investmentStep: InvestmentStep) {
    let sumNewPayout = 0;
    for (const etfIdentifier of Object.keys(investmentStep.newPayout) as ETFIdentifier[]) {
        sumNewPayout += investmentStep.newPayout[etfIdentifier];
    }
    return sumNewPayout;
}

/**
 * Creates a new date which is the given date + 1 month.
 *
 * @param date The concerning date.
 * @returns The given date increased by one month.
 */
function getNextMonthDate(date: Date): Date {
    const newDate = new Date(date);
    newDate.setMonth(date.getMonth() + 1);
    return newDate;
}

/**
 * Predicts the dividend for the etf at the given date.
 * If the date is not the last month of a year, zero is returned. Indicating that no divided payout has been done.
 * If the dividend prediction is 0 since all historic data is 0, then the defaultDividendAmount is used.
 *
 * @param etfIdentifier The concerning etfIdentifier.
 * @param date The concerning date.
 * @returns The predicted dividend for the given etf and date.
 */
function calculateDividend(etfIdentifier: string, date: Date, confidence: number, initialDate: Date): number {
    if (!isLastMonthOfAYear(date)) {
        return 0;
    } else {
        const dividendAmount = ForecastModelSingleton.getInstance().predictDividend(etfIdentifier, date.getFullYear());
        const sharePrice = ForecastModelSingleton.getInstance().predictCourse(
            etfIdentifier,
            date,
            confidence,
            initialDate
        );
        return dividendAmount > 0 ? dividendAmount : defaultDividendAmount * sharePrice;
    }
}

/**
 * Calculates the cost for the given money amount regarding the cost configuration.
 *
 * @param amount The amount of money to which the costs need to be applied.
 * @param costConfiguration The cost configuration consisting of fixed and percentage costs.
 * @returns The amount minus the costs and the costs itself.
 */
function calculateCosts(amount: number, costConfiguration: ICostConfiguration): [number, number] {
    let costs = amount * costConfiguration.percentageCosts + costConfiguration.fixedCosts;
    const amountWithoutCosts = Math.max(amount - costs, 0);
    costs = amount - amountWithoutCosts;
    return [amountWithoutCosts, costs];
}

/**
 * Subtracts the tax free amount from the tax amount and
 * returns the resulting leftover taxes and tax free amount.
 *
 * @param taxAmount The amount of taxes that need to be paid.
 * @param taxFreeAmount The tax free amount that is left and can be used.
 * @returns The leftover taxes and tax free amount.
 */
function subtractTaxFreeGain(taxAmount: number, taxFreeAmount: number): [number, number] {
    const leftoverTaxes = Math.max(0, taxAmount - taxFreeAmount);
    const leftoverTaxFreeAmount = Math.max(0, taxFreeAmount - taxAmount);
    return [leftoverTaxes, leftoverTaxFreeAmount];
}

/**
 * Calculates the sum of all etf share values of the portfolio.
 * I.e. returns the current value of the whole portfolio.
 *
 * @param investmentStep The concerning InvestmentStep.
 * @returns The sum of all total etf values.
 */
export function sumOfTotalValues(investmentStep: InvestmentStep): number {
    let sum = 0;
    for (const etfIdentifier of Object.keys(investmentStep.totalShares) as ETFIdentifier[]) {
        sum += getTotalShareValue(etfIdentifier, investmentStep);
    }
    return sum;
}

/**
 * Calculates and adds the amount of effective money loss caused by inflation
 * between the initialDate and the date of the investment step.
 *
 * @param investmentStep The concerning investmentStep.
 * @param initialDate The initial date of the whole investment model.
 */
function calculateAndAddInflation(investmentStep: InvestmentStep, initialDate: Date): void {
    const sumTotalValues = sumOfTotalValues(investmentStep);
    const date = investmentStep.date;
    const timeFactor =
        date.getFullYear() -
        initialDate.getFullYear() +
        (date.getMonth() - initialDate.getMonth()) / numberOfMonthsOfAYear;
    investmentStep.inflation = sumTotalValues - sumTotalValues * Math.pow(1 - inflationRate, timeFactor);
}

/**
 * Calculates the amount increase in a accumulative fashion for every passed year.
 *
 * @param amount The initial amount.
 * @param percentageIncrease The percentage increase of the amount per year.
 * @param numberOfMonths The number of months passed since the investment model start.
 * @returns The amount increased by the percentage for every passed year in an accumulative way.
 */
function calculateAmountIncrease(amount: number, percentageIncrease: number, numberOfMonths: number): number {
    const yearsSinceStart = Math.floor(numberOfMonths / numberOfMonthsOfAYear);
    return amount * Math.pow(1 + percentageIncrease, yearsSinceStart);
}

/**
 * Calculates the forecast interval of the model and all necessary dates.
 * Divides the interval in saving and payout phase. Adds the fade out years
 * to the life expectation to indicate that death is expected in that phase.
 *
 * @param age The age of the person.
 * @param lifeExpectation The life expectation of the person.
 * @param savingPhaseLength The saving phase length of the person.
 * @param fadeOutYears The length of the fade out years.
 * @returns The three dates indicating the start of the saving phase, the start of the payout phase and the end of the payout phase.
 */
function calculateForecastInterval(
    age: number,
    lifeExpectation: number,
    savingPhaseLength: number,
    fadeOutYears: number = 10
): [Date, Date, Date] {
    const yearsLeft = lifeExpectation - age;
    const now = new Date();
    const beginningDate = new Date(now.getFullYear(), now.getMonth() + 1);
    // start next month.
    const endSavingPhaseDate = new Date(beginningDate);
    endSavingPhaseDate.setFullYear(beginningDate.getFullYear() + savingPhaseLength);
    const endDate = new Date(beginningDate);
    endDate.setFullYear(beginningDate.getFullYear() + yearsLeft + fadeOutYears);
    return [beginningDate, endSavingPhaseDate, endDate];
}

/**
 * Calculates the Vorabpauschale for the last year. Thus is zero if the month is not January.
 *
 * @param investmentSteps All investmentSteps already calculated for the model.
 * @param date The date of the concerning investment step.
 * @param leftoverTaxFreeAmount The leftover tax free amount.
 * @param etfToRatio The etfIdentifier mapping to the ratio.
 * @returns The amount of taxes to pay and the leftover tax free amount.
 */
function calculateVorabpauschaleTaxes(
    investmentSteps: InvestmentStep[],
    date: Date,
    leftoverTaxFreeAmount: number,
    etfToRatio: ETFRatio
): [number, number] {
    // TODO: tax amount auf das new investment draufrechnen.
    if (!isFirstMonthOfAYear(date) || investmentSteps.length < 2) {
        return [0, leftoverTaxFreeAmount];
    }
    let summedTaxes = 0;
    const decemberInvestmentStep = investmentSteps[investmentSteps.length - 1];
    // Use the second investment step if there are not enough meaning the investing started this year after january.
    // The second is the true first investment step the first is a dummy.
    const firstInvestmentStepOfThisYear =
        investmentSteps.length - numberOfMonthsOfAYear > 1
            ? investmentSteps[investmentSteps.length - numberOfMonthsOfAYear]
            : investmentSteps[1];
    for (const etfIdentifier of Object.keys(etfToRatio) as ETFIdentifier[]) {
        const distributionsOfETF = decemberInvestmentStep.distributingNewAmount[etfIdentifier];
        // Sum up total Investment of the first date of this year.
        let accumulatedBasicProfit =
            (getTotalShareValue(etfIdentifier, firstInvestmentStepOfThisYear) *
                (numberOfMonthsOfAYear - firstInvestmentStepOfThisYear.date.getMonth())) /
            numberOfMonthsOfAYear;
        // Sum up all new investments from february to december.
        for (let i = 1; i < numberOfMonthsOfAYear && investmentSteps.length - i > 0; i++) {
            const currentInvestmentStep = investmentSteps[investmentSteps.length - i];
            accumulatedBasicProfit +=
                (getNewShareValue(etfIdentifier, currentInvestmentStep) * i) / numberOfMonthsOfAYear;
        }
        accumulatedBasicProfit *= 0.7 * basicRateOfInterest;
        // If there were more distributions than the base profit, no vorabpauschale needs to be paid.
        if (distributionsOfETF >= accumulatedBasicProfit) {
            continue;
        }
        const currentShareValues = getTotalShareValue(etfIdentifier, decemberInvestmentStep);
        // Calculate profit of last year.
        const profitOverAllTime = currentShareValues - decemberInvestmentStep.totalInvestedMoney[etfIdentifier];
        let profitOfPreviousYears = 0;
        if (investmentSteps.length > numberOfMonthsOfAYear) {
            profitOfPreviousYears = Math.max(
                0,
                getTotalShareValue(etfIdentifier, investmentSteps[investmentSteps.length - 1 - numberOfMonthsOfAYear]) -
                    investmentSteps[investmentSteps.length - 1 - numberOfMonthsOfAYear].totalInvestedMoney[
                        etfIdentifier
                    ]
            );
        }

        const profitOfThisYear = profitOverAllTime - profitOfPreviousYears;
        let amountToApplyTaxes = clamp(profitOfThisYear, 0, accumulatedBasicProfit);
        [amountToApplyTaxes, leftoverTaxFreeAmount] = subtractTaxFreeGain(amountToApplyTaxes, leftoverTaxFreeAmount);
        summedTaxes += amountToApplyTaxes * partialExemption * corporateTaxRatio;
    }
    return [summedTaxes, leftoverTaxFreeAmount];
}

/**
 * Adds an accumulating month to the investment model.
 *
 * @param investmentSteps The whole investment model.
 * @param investment The amount of money to invest this month.
 * @param date The date of the new investment step.
 * @param initialDate The initial date of the investment model.
 * @param etfToRatio The etfIdentifier mapping to the ratio.
 * @param leftoverTaxFreeAmount The leftover tax free amount of this year. Is automatically reset in January.
 * @param useDistributingModel Determines the Model used for the calculation. Distributing vs. Accumulating.
 * @param configOptions The configuration options containing the tax free amount and cost configuration.
 */
function addSavingPhaseMonth(
    investmentSteps: InvestmentStep[],
    investment: number,
    date: Date,
    initialDate: Date,
    etfToRatio: ETFRatio,
    configOptions: IConfigOptions,
    leftoverTaxFreeAmount: number,
    useDistributingModel: boolean
): number {
    // Reset tax free amount every beginning year.
    if (isFirstMonthOfAYear(date)) {
        leftoverTaxFreeAmount = configOptions.taxFreeAmount;
    }
    let costs = 0;
    const prevInvestmentStep = investmentSteps[investmentSteps.length - 1];
    const newInvestmentStep = cloneDeep(prevInvestmentStep);
    newInvestmentStep.date = date;
    newInvestmentStep.newInvestment = 0;

    for (const etfIdentifier of Object.keys(etfToRatio) as ETFIdentifier[]) {
        // Handle investment amount and costs.
        const investmentOfEtfWithCosts = (etfToRatio[etfIdentifier] as number) * investment;
        newInvestmentStep.newInvestment += investmentOfEtfWithCosts;
        const [investmentOfEtfWithoutCosts, newCosts] = calculateCosts(
            investmentOfEtfWithCosts,
            configOptions.costConfig
        );
        costs += newCosts;
        newInvestmentStep.newInvestedMoney[etfIdentifier] = investmentOfEtfWithoutCosts;
        newInvestmentStep.totalInvestedMoney[etfIdentifier] += investmentOfEtfWithoutCosts;

        // Handle new shares and price.
        const etfSharePrice = ForecastModelSingleton.getInstance().predictCourse(
            etfIdentifier,
            date,
            configOptions.confidence,
            initialDate
        );
        const newShares = investmentOfEtfWithoutCosts / etfSharePrice;
        newInvestmentStep.sharePrices[etfIdentifier] = etfSharePrice;
        newInvestmentStep.newShares[etfIdentifier] = newShares;

        // Handle dividend.
        const dividendPayoutMoneyPerShare = calculateDividend(
            etfIdentifier,
            date,
            configOptions.confidence,
            initialDate
        );
        let dividendPayoutMoney = newInvestmentStep.totalShares[etfIdentifier] * dividendPayoutMoneyPerShare;

        if (useDistributingModel) {
            newInvestmentStep.distributingNewAmount[etfIdentifier] = dividendPayoutMoney;
            let dividendPayoutMoneyBrutto = dividendPayoutMoney;
            let leftoverDividendPayoutMoneyBrutto;
            [leftoverDividendPayoutMoneyBrutto, leftoverTaxFreeAmount] = subtractTaxFreeGain(
                dividendPayoutMoneyBrutto,
                leftoverTaxFreeAmount
            );
            let taxesToPay = leftoverDividendPayoutMoneyBrutto * partialExemption * corporateTaxRatio;
            newInvestmentStep.totalTaxes += taxesToPay;
            dividendPayoutMoney = dividendPayoutMoneyBrutto - taxesToPay;
        }
        const newSharesByDividend = dividendPayoutMoney / etfSharePrice;
        newInvestmentStep.newShares[etfIdentifier] += newSharesByDividend;
        if (!useDistributingModel) {
            newInvestmentStep.dividendNewShares[etfIdentifier] = newSharesByDividend;
            newInvestmentStep.dividendTotalShares[etfIdentifier] += newSharesByDividend;
        }

        // Adjust other values.
        newInvestmentStep.totalShares[etfIdentifier] += newInvestmentStep.newShares[etfIdentifier];
        newInvestmentStep.newPayout[etfIdentifier] = 0;
    }

    // Handle costs, taxes and inflation.
    newInvestmentStep.totalCosts += costs;
    const [newTaxes] = calculateVorabpauschaleTaxes(investmentSteps, date, configOptions.taxFreeAmount, etfToRatio);
    newInvestmentStep.totalTaxes += newTaxes;
    calculateAndAddInflation(newInvestmentStep, initialDate);
    investmentSteps.push(newInvestmentStep);
    return leftoverTaxFreeAmount;
}

/**
 * Adds a payout month step to the investment model.
 *
 * @param investmentSteps The whole investment model.
 * @param sellingAmount The money amount of shares to sell this month.
 * @param etfToRatio The etfIdentifier mapping to the ratio.
 * @param date The date of the new payout step.
 * @param initialDate The initial date of the investment model.
 * @param configOptions The configuration options containing the tax free amount and cost configuration.
 * @param leftoverAlreadyPaidTaxes The leftover amount of taxes that have already been paid.
 * @param leftoverTaxFreeAmount The leftover tax free amount.
 * @param payoutStats The payout stats containing which investment step is next and what shares are left according to the FIFO principle.
 * @param useDistributingModel Determines the Model used for the calculation. Distributing vs. Accumulating.
 * @returns The updated leftoverAlreadyPaidTaxes and leftoverTaxFreeAmount.
 */
function addPayoutMonth(
    investmentSteps: InvestmentStep[],
    sellingAmount: number,
    etfToRatio: ETFRatio,
    date: Date,
    initialDate: Date,
    configOptions: IConfigOptions,
    leftoverAlreadyPaidTaxes: number,
    leftoverTaxFreeAmount: number,
    payoutStats: IPayoutStats,
    useDistributingModel: boolean
) {
    if (isFirstMonthOfAYear(date)) {
        leftoverTaxFreeAmount = configOptions.taxFreeAmount;
    }
    let costs = 0;
    let taxes = 0;
    const prevInvestmentStep = investmentSteps[investmentSteps.length - 1];
    const newInvestmentStep = cloneDeep(prevInvestmentStep);
    newInvestmentStep.date = date;
    newInvestmentStep.newInvestment = 0;

    for (const etfIdentifier of Object.keys(etfToRatio) as ETFIdentifier[]) {
        const etfSharePrice = ForecastModelSingleton.getInstance().predictCourse(
            etfIdentifier,
            date,
            configOptions.confidence,
            initialDate
        );
        let amountToSell = (etfToRatio[etfIdentifier] as number) * sellingAmount;
        // Set default values.
        newInvestmentStep.sharePrices[etfIdentifier] = etfSharePrice;
        newInvestmentStep.newPayout[etfIdentifier] = 0;
        newInvestmentStep.newInvestedMoney[etfIdentifier] = 0;
        // Handle dividend.
        const dividendPayoutMoneyPerShare = calculateDividend(
            etfIdentifier,
            date,
            configOptions.confidence,
            initialDate
        );
        const dividendPayoutMoney = newInvestmentStep.totalShares[etfIdentifier] * dividendPayoutMoneyPerShare;

        // Apply taxes if using distributing model.
        if (useDistributingModel) {
            newInvestmentStep.distributingNewAmount[etfIdentifier] = dividendPayoutMoney;
            let dividendPayoutMoneyBrutto = dividendPayoutMoney;
            let leftoverDividendPayoutMoneyBrutto;
            [leftoverDividendPayoutMoneyBrutto, leftoverTaxFreeAmount] = subtractTaxFreeGain(
                dividendPayoutMoneyBrutto,
                leftoverTaxFreeAmount
            );
            let taxesToPay = leftoverDividendPayoutMoneyBrutto * partialExemption * corporateTaxRatio;
            [taxesToPay, leftoverAlreadyPaidTaxes] = subtractTaxFreeGain(taxesToPay, leftoverAlreadyPaidTaxes);
            newInvestmentStep.totalTaxes += taxesToPay;
            const dividendPayout = dividendPayoutMoneyBrutto - taxesToPay;
            newInvestmentStep.distributingAmountUsableForPayout[etfIdentifier] = dividendPayout;
            newInvestmentStep.newShares[etfIdentifier] = 0;
        } else {
            const newSharesByDividend = dividendPayoutMoney / etfSharePrice;
            newInvestmentStep.newShares[etfIdentifier] = newSharesByDividend;
            newInvestmentStep.totalShares[etfIdentifier] += newSharesByDividend;
            newInvestmentStep.dividendNewShares[etfIdentifier] = newSharesByDividend;
            newInvestmentStep.dividendTotalShares[etfIdentifier] += newSharesByDividend;
        }

        const amountUsedByDistribution = Math.min(
            amountToSell,
            newInvestmentStep.distributingAmountUsableForPayout[etfIdentifier]
        );
        amountToSell -= amountUsedByDistribution;
        newInvestmentStep.distributingAmountUsableForPayout[etfIdentifier] -= amountUsedByDistribution;
        newInvestmentStep.newPayout[etfIdentifier] += amountUsedByDistribution;

        let amountAlreadySold = 0;
        // Skip payout if there are no shares left to sell or the payout is covered by the dividend.
        if (payoutStats[etfIdentifier].investmentStepsIdx < investmentSteps.length && amountToSell > 0) {
            // Prepare amount and costs.
            const costsToPay = calculateCosts(amountToSell, configOptions.costConfig)[1];
            let alreadyPaidCosts = 0;
            let payoutInvestmentStepIdxForFIFO = payoutStats[etfIdentifier].investmentStepsIdx;
            let currentSharesLeft =
                investmentSteps[payoutInvestmentStepIdxForFIFO].newShares[etfIdentifier] -
                payoutStats[etfIdentifier].alreadySoldShares;
            // Iterate over all investment steps according to the FIFO principle and sell as much shares as needed.
            for (; payoutInvestmentStepIdxForFIFO < investmentSteps.length; payoutInvestmentStepIdxForFIFO++) {
                const currentInvestmentStepForFIFO = investmentSteps[payoutInvestmentStepIdxForFIFO];
                const leftoverAmountToSell = amountToSell - amountAlreadySold;

                // Calculate the amount of shares to sell and the leftover shares.
                const currentValueOfShares =
                    etfSharePrice *
                    (payoutInvestmentStepIdxForFIFO === payoutStats[etfIdentifier].investmentStepsIdx
                        ? currentInvestmentStepForFIFO.newShares[etfIdentifier] -
                          payoutStats[etfIdentifier].alreadySoldShares
                        : currentInvestmentStepForFIFO.newShares[etfIdentifier]);
                const amountToSellWithCosts = Math.min(currentValueOfShares, leftoverAmountToSell);
                const amountOfSharesToSell = amountToSellWithCosts / etfSharePrice;
                currentSharesLeft = currentInvestmentStepForFIFO.newShares[etfIdentifier] - amountOfSharesToSell;
                currentSharesLeft -=
                    payoutInvestmentStepIdxForFIFO === payoutStats[etfIdentifier].investmentStepsIdx
                        ? payoutStats[etfIdentifier].alreadySoldShares
                        : 0;

                // Apply costs to the sold shares.
                const amountToSellWithoutCosts = Math.max(0, amountToSellWithCosts - (costsToPay - alreadyPaidCosts));
                alreadyPaidCosts += Math.max(0, amountToSellWithCosts - amountToSellWithoutCosts);

                // Calculate amount on which taxes need to be paid.
                const initialValueOfShares =
                    amountOfSharesToSell * currentInvestmentStepForFIFO.sharePrices[etfIdentifier];
                let amountToPayTaxes = Math.max(0, amountToSellWithoutCosts - initialValueOfShares);

                // Apply taxes.
                [amountToPayTaxes, leftoverTaxFreeAmount] = subtractTaxFreeGain(
                    amountToPayTaxes,
                    leftoverTaxFreeAmount
                );
                let taxesToPay = amountToPayTaxes * partialExemption * corporateTaxRatio;
                [taxesToPay, leftoverAlreadyPaidTaxes] = subtractTaxFreeGain(taxesToPay, leftoverAlreadyPaidTaxes);
                taxes += taxesToPay;
                const payoutAmount = amountToSellWithoutCosts - taxesToPay;

                // Set resulting values.
                newInvestmentStep.newPayout[etfIdentifier] += payoutAmount;
                newInvestmentStep.totalPayout[etfIdentifier] += payoutAmount;

                newInvestmentStep.totalShares[etfIdentifier] -= amountOfSharesToSell;
                amountAlreadySold += amountToSellWithCosts;

                // Handle the decrease of the dividendShares.
                let amountOfDividendSharesLeft = 0;
                if (payoutInvestmentStepIdxForFIFO === payoutStats[etfIdentifier].investmentStepsIdx) {
                    amountOfDividendSharesLeft = Math.max(
                        0,
                        currentInvestmentStepForFIFO.dividendNewShares[etfIdentifier] -
                            payoutStats[etfIdentifier].alreadySoldShares
                    );
                } else {
                    amountOfDividendSharesLeft = currentInvestmentStepForFIFO.dividendNewShares[etfIdentifier];
                }
                const amountOfDividendSharesSold = Math.min(amountOfDividendSharesLeft, amountOfSharesToSell);
                newInvestmentStep.dividendTotalShares[etfIdentifier] -= amountOfDividendSharesSold;

                // Use break in order to not change the value of payoutInvestmentStepIdxForFIFO.
                if (amountAlreadySold >= amountToSell) {
                    break;
                }
            }
            // Handle update payoutStats.
            costs += alreadyPaidCosts;
            payoutStats[etfIdentifier].investmentStepsIdx = payoutInvestmentStepIdxForFIFO;

            payoutStats[etfIdentifier].alreadySoldShares =
                payoutInvestmentStepIdxForFIFO < investmentSteps.length
                    ? investmentSteps[payoutInvestmentStepIdxForFIFO].newShares[etfIdentifier] - currentSharesLeft
                    : 0;
        }
        // Handle Vorabpauschale.
        const [newTaxes, newLeftoverTaxFreeAmount] = calculateVorabpauschaleTaxes(
            investmentSteps,
            date,
            leftoverTaxFreeAmount,
            etfToRatio
        );
        leftoverTaxFreeAmount = newLeftoverTaxFreeAmount;
        taxes += newTaxes;
        leftoverAlreadyPaidTaxes += newTaxes;
    }

    // Set resulting values and inflation.
    newInvestmentStep.totalCosts += costs;
    newInvestmentStep.totalTaxes += taxes;
    calculateAndAddInflation(newInvestmentStep, initialDate);
    investmentSteps.push(newInvestmentStep);
    return [leftoverAlreadyPaidTaxes, leftoverTaxFreeAmount];
}

/**
 * Creates a dummy investment step intended to be the first investment step in the model
 * in order to avoid if statements in the other investment methods checking whether this is the first step or not.
 *
 * @param etfToRatio The etfIdentifier mapping to the ratio.
 * @param date The starting date of the investment model.
 * @returns A dummy investment step.
 */
function generateEmptyInvestmentStep(etfToRatio: ETFRatio, date: Date, configOptions: IConfigOptions): InvestmentStep {
    const dummyData: ETFShares = { 'SP5C.PAR': 0, ESGE: 0, SUSA: 0 };
    const emptyInvestmentStep: InvestmentStep = {
        date: date,
        totalCosts: 0,
        totalTaxes: 0,
        newShares: { ...dummyData },
        totalShares: { ...dummyData },
        dividendNewShares: { ...dummyData },
        dividendTotalShares: { ...dummyData },
        distributingNewAmount: { ...dummyData },
        distributingAmountUsableForPayout: { ...dummyData },
        totalInvestedMoney: { ...dummyData },
        totalPayout: { ...dummyData },
        newPayout: { ...dummyData },
        sharePrices: { ...dummyData },
        newInvestedMoney: { ...dummyData },
        newInvestment: 0,
        inflation: 0,
    };
    for (const etfIdentifier of Object.keys(etfToRatio) as ETFIdentifier[]) {
        emptyInvestmentStep.newShares[etfIdentifier] = 0;
        emptyInvestmentStep.totalShares[etfIdentifier] = 0;
        emptyInvestmentStep.dividendNewShares[etfIdentifier] = 0;
        emptyInvestmentStep.dividendTotalShares[etfIdentifier] = 0;
        emptyInvestmentStep.totalInvestedMoney[etfIdentifier] = 0;
        emptyInvestmentStep.totalPayout[etfIdentifier] = 0;
        emptyInvestmentStep.newPayout[etfIdentifier] = 0;
        emptyInvestmentStep.newInvestedMoney[etfIdentifier] = 0;
        emptyInvestmentStep.sharePrices[etfIdentifier] = ForecastModelSingleton.getInstance().predictCourse(
            etfIdentifier,
            date,
            configOptions.confidence,
            date
        );
    }
    return emptyInvestmentStep;
}

/**
 * Creates the investment model for the visualization which consists of arrays of an object
 * which contain all important values for the visualization.
 * It can deliver the model with different levels of detail meaning that one step covers more than one month.
 *
 * Example code:
 * ```typescript
 * const investmentModel = new InvestmentModel(...uiParams);
 * // 2 => every investment step will cover 6 Months.
 * const dataVorTheVisualization = investmentModel.getInvestmentSteps(2);
 * ```
 */
export class InvestmentModel {
    private startCapital: number;
    private monthlyInvestment: number;
    private yearlyInvestmentIncrease: number;
    private monthlyPayout: number;
    private yearlyPayoutIncrease: number;
    private savingPhaseLength: number;
    private etfToRatio: ETFRatio;
    private configOptions: IConfigOptions;
    private expectationOfLife: number;
    private age: number;
    private useDistributingModel: boolean;

    private savingDates: Date[] = [];
    private payoutDates: Date[] = [];
    private initialDate: Date = new Date();
    private investmentSteps: InvestmentStep[] = [];

    /**
     * Constructs and calculates the investment model.
     *
     * @param startCapital The starting capital.
     * @param monthlyInvestment The monthly investment.
     * @param yearlyInvestmentIncrease The yearly investment increase given as a percentage in float representation.
     * @param monthlyPayout The monthly payout.
     * @param yearlyPayoutIncrease The yearly payout increase given as a percentage in float representation.
     * @param savingPhaseLength The length of the saving phase.
     * @param etfToRatio The etfIdentifier mapping to the ratio.
     * @param configOptions The config options containing the tax free amount and cost configuration.
     * @param age The current age of the person.
     * @param expectationOfLife The life expectation of the person.
     * @param useDistributingModel Indicate which model should be used.
     */
    constructor(
        startCapital: number,
        monthlyInvestment: number,
        yearlyInvestmentIncrease: number,
        monthlyPayout: number,
        yearlyPayoutIncrease: number,
        savingPhaseLength: number,
        etfToRatio: ETFRatio,
        configOptions: IConfigOptions,
        age: number,
        expectationOfLife: number,
        useDistributingModel: boolean
    ) {
        this.startCapital = startCapital;
        this.monthlyInvestment = monthlyInvestment;
        this.monthlyPayout = monthlyPayout;
        this.savingPhaseLength = savingPhaseLength;
        this.etfToRatio = etfToRatio;
        this.configOptions = configOptions;
        this.expectationOfLife = expectationOfLife;
        this.age = age;
        this.yearlyInvestmentIncrease = yearlyInvestmentIncrease;
        this.yearlyPayoutIncrease = yearlyPayoutIncrease;
        this.useDistributingModel = useDistributingModel;

        this._calculateDatesForModel();
        this._calculateModel();
    }

    /**
     * Calculates all necessary dates for the saving and payout phase.
     */
    private _calculateDatesForModel() {
        const [startDate, endSavingPhaseDate, endDate] = calculateForecastInterval(
            this.age,
            this.expectationOfLife,
            this.savingPhaseLength
        );
        const savingDates = [];
        for (
            let currentDate = startDate;
            currentDate < endSavingPhaseDate;
            currentDate = getNextMonthDate(currentDate)
        ) {
            savingDates.push(currentDate);
        }
        this.savingDates = savingDates;
        const payoutDates = [];
        for (let currentDate = endSavingPhaseDate; currentDate < endDate; currentDate = getNextMonthDate(currentDate)) {
            payoutDates.push(currentDate);
        }
        this.payoutDates = payoutDates;
        this.initialDate = startDate;
    }

    /**
     * Calculates the investment model by first adding all investment and the payout dates.
     */
    private _calculateModel() {
        let investmentSteps = [generateEmptyInvestmentStep(this.etfToRatio, this.savingDates[0], this.configOptions)];
        let leftoverTaxFreeAmount = addSavingPhaseMonth(
            investmentSteps,
            this.monthlyInvestment + this.startCapital,
            this.savingDates[0],
            this.initialDate,
            this.etfToRatio,
            this.configOptions,
            this.configOptions.taxFreeAmount,
            this.useDistributingModel
        );
        for (let i = 1; i < this.savingDates.length; i++) {
            const investmentAmount = calculateAmountIncrease(this.monthlyInvestment, this.yearlyInvestmentIncrease, i);
            addSavingPhaseMonth(
                investmentSteps,
                investmentAmount,
                this.savingDates[i],
                this.initialDate,
                this.etfToRatio,
                this.configOptions,
                leftoverTaxFreeAmount,
                this.useDistributingModel
            );
        }
        // Discard the empty investment step.
        investmentSteps = investmentSteps.slice(1);

        let leftoverAlreadyPaidTaxes = this.useDistributingModel
            ? 0
            : investmentSteps[investmentSteps.length - 1].totalTaxes;
        const payoutStats: IPayoutStats = {
            'SP5C.PAR': { investmentStepsIdx: 0, alreadySoldShares: 0 },
            ESGE: { investmentStepsIdx: 0, alreadySoldShares: 0 },
            SUSA: { investmentStepsIdx: 0, alreadySoldShares: 0 },
        };
        for (let i = 0; i < this.payoutDates.length; i++) {
            const payoutAmount = calculateAmountIncrease(this.monthlyPayout, this.yearlyPayoutIncrease, i);
            [leftoverAlreadyPaidTaxes, leftoverTaxFreeAmount] = addPayoutMonth(
                investmentSteps,
                payoutAmount,
                this.etfToRatio,
                this.payoutDates[i],
                this.initialDate,
                this.configOptions,
                leftoverAlreadyPaidTaxes,
                leftoverTaxFreeAmount,
                payoutStats,
                this.useDistributingModel
            );
        }
        this.investmentSteps = investmentSteps;
    }

    /**
     * Returns the investment model with the given level of detail.
     *
     * numberOfEntriesPerYear = 1 will result in one investment Step per year and
     * numberOfEntriesPerYear = 12 will change nothing on the model.
     *
     * NOTE: Only the newInvestment and newPayout values are adjusted when investment steps need to be merged
     * since the current visualizations need no further adjustments.
     *
     * @param numberOfEntriesPerYear The number of investment steps per year.
     * @returns
     */
    getInvestmentSteps(numberOfEntriesPerYear: number) {
        if (!Number.isInteger(numberOfMonthsOfAYear / numberOfEntriesPerYear)) {
            throw new Error(
                `The numberOfEntriesPerYear need to be dividable by ${numberOfMonthsOfAYear} in order to make sense.`
            );
        }

        if (numberOfEntriesPerYear === numberOfMonthsOfAYear) {
            return this.investmentSteps;
        }
        const selectedInvestmentSteps = [];
        const numberOfMonthsToMerge = numberOfMonthsOfAYear / numberOfEntriesPerYear;
        for (let i = 0; i < this.investmentSteps.length; i += numberOfMonthsToMerge) {
            // Take the start date of the period as the representation.
            const adjustedInvestmentStep = cloneDeep(this.investmentSteps[i]);
            for (let offset = 1; offset < numberOfMonthsToMerge; offset++) {
                adjustedInvestmentStep.newInvestment += this.investmentSteps[i + offset].newInvestment;
                for (const etfIdentifier of Object.keys(
                    this.investmentSteps[i + offset].newPayout
                ) as ETFIdentifier[]) {
                    adjustedInvestmentStep.newPayout[etfIdentifier] +=
                        this.investmentSteps[i + offset].newPayout[etfIdentifier];
                }
            }
            selectedInvestmentSteps.push(adjustedInvestmentStep);
        }
        return selectedInvestmentSteps;
    }

    /**
     * Returns the first payout date of the model.
     * @returns The first payoutDate.
     */
    getPayoutPhaseBeginDate() {
        return this.payoutDates[0];
    }
}
